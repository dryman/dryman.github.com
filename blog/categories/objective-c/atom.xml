<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Objective-C | Carpe diem (Felix's blog)]]></title>
  <link href="http://www.idryman.org/blog/categories/objective-c/atom.xml" rel="self"/>
  <link href="http://www.idryman.org/"/>
  <updated>2014-01-25T17:11:10-08:00</updated>
  <id>http://www.idryman.org/</id>
  <author>
    <name><![CDATA[dryman (Felix Ren-Chyan Chern)]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Objective-C ARC common pitfalls and best practices]]></title>
    <link href="http://www.idryman.org/blog/2012/11/22/arc-best-practices-and-pitfalls/"/>
    <updated>2012-11-22T09:28:00-08:00</updated>
    <id>http://www.idryman.org/blog/2012/11/22/arc-best-practices-and-pitfalls</id>
    <content type="html"><![CDATA[<p>Objective-C is a really cool programming language that is designed for Mac OSX and
iOS software development. TIOBE has announced November Haedline: <a href="http://www.tiobe.com/index.php/content/paperinfo/tpci/index.html">Objective-C on
its way to become “language of the year” again</a>. It is popular not only because
the platform, but also its great performance on mobile devices. Objective-C
featured in its manually memory management instead of garbage collection. Yet,
its not that <em>manual</em> in modern Objective-C. Apple introduced Automatic
Reference Counting, ARC, that inserts memory management code for you on compile
time. In most cases of Objective-C development, it JUST WORKS. However, it
is often confusing when you mix ARC code with Core Foundation objects (low level
C references on apple’s platform). Today, I’ll talk about pitfalls and concepts
of ARC especially when gluing CF objects with <strong>toll-free bridging</strong>.</p>

<!-- more -->

<h2 id="daily-arc">Daily ARC</h2>

<p>I’ll first make a quick go through of ARC in two major uses: Objective-C
properties and ARC type qualifiers. Then we’ll cut deep into memory management
of Core Foundation Framework.</p>

<h3 id="arc-and-objective-c-properties">ARC and Objective-C properties</h3>

<script language="javascript">
function toggleContent(){
    var link = document.getElementById("expand_link");
    var content = document.getElementById("expand_content");
    if (content.style.display == 'block') {
        content.style.display = 'none';
        link.innerHTML = "Expand my highlight of ARC best pracitices by @amattn";
    } else {
        content.style.display = 'block';
        link.innerHTML = "Toggle highlight";
    }
}
</script>

<p>It is really hard to write a new article about ARC without <a href="https://twitter.com/amattn">@amattn</a>’s
collection of <a href="http://amattn.com/2011/12/07/arc_best_practices.html">ARC Best Practices</a>. You can find the complete
best practices there, and below <a href="javascirpt:toggleContent()">link</a>
is my highlight of his article <sup id="fnref:foot"><a href="#fn:foot" rel="footnote">1</a></sup>:</p>

<p><a id="expand_link" href="javascript:toggleContent()"> Expand my highlight of ARC best pracitices by @amattn</a> </p>

<blockquote style="display: none;" id="expand_content" cite="http://amattn.com/2011/12/07/arc_best_practices.html">

  <ul>
    <li>object instance variables which needs to be retained should use <code>strong</code>.</li>
  </ul>

  <p><code>obj-c
@property (nonatomic, strong) id childObject;
</code></p>

  <ul>
    <li>To break reference cycle, use <code>weak</code> <sup id="fnref:foot2"><a href="#fn:foot2" rel="footnote">2</a></sup>.</li>
  </ul>

  <p><code>obj-c
@property (nonatomic, weak) id delegate;
@property (nonatomic, weak) NSTimer timer; // NSTimer retains target
</code></p>

  <ul>
    <li>use <code>assign</code> for scalar properties</li>
  </ul>

  <p><code>obj-c
@property (nonatomic, assign) CGFloat width;
@property (nonatomic, assign) CGFloat height;
</code></p>

  <ul>
    <li>use <code>copy</code> for immutable containers, strings and block. Avoid using mutable
containers in properties (<code>NSMutableArray</code>, for example.) If you use mutable
containers, use <code>strong</code>.</li>
  </ul>

  <p><code>obj-c
@property (nonatomic, copy) NSString* name;
@property (nonatomic, copy) NSArray* components;
@property (nonatomic, copy) (void (^)(void)) job;
@property (nonatomic, strong) NSMutableArray* badPatterns;
</code></p>

  <ul>
    <li>In dealloc
      <ul>
        <li>remove observers</li>
        <li>unregister notifications</li>
      </ul>
    </li>
    <li>IBOutlets should generally be <code>weak</code> except File’s Owner to top-level objects in
a nib file. If you set it to <code>strong</code>, you should set it to <code>nil</code> in
<code>-(void)viewDidUnload</code>.</li>
  </ul>

  <footer><cite><a href="http://amattn.com/2011/12/07/arc_best_practices.html"> ARC Best Practices</a></cite></footer>
</blockquote>

<h3 id="arc-specific-type-qualifiers">ARC specific type qualifiers</h3>

<p>About type qualifier rules, you can see my <a href="http://www.idryman.org/blog/2012/10/29/type-qualifiers/">previous post</a>. There
are four ARC specific type qualifiers introduced by Apple:</p>

<ol>
  <li><code>__strong</code> is the default. An object remains <strong>alive</strong> as long as there is a strong
  pointer to it.</li>
  <li><code>__weak</code> specifies a reference that does not keep the referenced object alive. A
  weak reference is set to <code>nil</code> when there are no strong references to the object.</li>
  <li><code>__unsafe_unretained</code> specifies a reference that does not keep the referenced
  object alive and is not set to <code>nil</code> when there are no strong references to the
  object. If the object it references is deallocated, the pointer is left
  dangling.</li>
  <li><code>__autoreleasing</code> is used to denote arguments that are passed by reference <code>(id *)</code>
  and are autoreleased on return.</li>
</ol>

<p>Beware that ARC type qualifiers are used for POINTER TYPE. That is, you must put
the qualifier at the right hand side of the star. </p>

<p>```obj-c
MyClass * __weak w_self = self;    // correct
MyClass __weak * w_self = self;    // wrong! May cause serious bugs!
__weak MyClass * w_self = self;    // wrong!</p>

<p>__weak typeof(self) w_self = self; 
// correct, will expand to (See gcc manual of typeof)
// __weak (MyClass *) w_self = self;</p>

<p>typeof(self) __weak w_self = self; // correct, its safer
```</p>

<p>You might wonder that there is so many wrong format on the internet. But
[Apple officially] said so:</p>

<blockquote>
  <p>You should decorate variables correctly. When using qualifiers in an object
variable declaration, the correct format is:
<code>ClassName * qualifier variableName;</code></p>
</blockquote>

<h2 id="arc-and-toll-free-bridging">ARC and toll-free bridging</h2>

<p>The biggest problem of ARC occurs when you mix it with Core Foundation
references. The rules of thumb are</p>

<ul>
  <li>When you transfer an Objective-C object to a CF reference, you
retain it.</li>
  <li>When you transfer a CF reference to an Objective-C object, you
release it.</li>
  <li>It is dangerous if you didn’t change ownership of objects. Sometimes Clang
corrects it for you, sometimes don’t.</li>
  <li>There is no autorelease in Core Foundation, and you must follow the Core
Foundation memory management naming convention:
    <ul>
      <li>Those object returned from function with <code>Create</code> or <code>Copy</code>, you <strong>own</strong> the
object, thus you must release it.</li>
      <li>If the function name contains the word <code>Get</code>, you do not own the object. Do
not release it.</li>
    </ul>
  </li>
</ul>

<p>There are two ways to retain a CF object: a type casting like syntax
<code>(__bridge_retained)</code> or C function <code>CFBridgingRetain</code>.  Though clang show up
diagnostics to use the former syntax, I prefer to use the latter one because it
is easier to read for me. </p>

<p><code>obj-c
CFArrayRef arr = CFBridgingRetain( @[@"abc", @"def", @3.14] );
// or CFArrayRef arr = (__bridge_retained CFArrayRef)@[...];
// do stuffs..
CFRelease(arr);
</code></p>

<p>When you get an object from Core Foundation with name containing <code>Create</code> or
<code>Copy</code>, use <code>(__bridge_transfer)</code> or <code>CFBridgingRelease</code>.</p>

<p>```obj-c
- (void)logFirstNameOfPerson:(ABRecordRef)person {</p>

<pre><code>NSString *name = (NSString *)CFBridgingRelease(ABRecordCopyValue(person, kABPersonFirstNameProperty));
NSLog(@"Person's first name: %@", name); } ```
</code></pre>

<h2 id="pitfalls-in-toll-free-bridging">Pitfalls in toll-free bridging</h2>

<p>When you see a code like this:</p>

<p><code>obj-c
- (CGColorRef)foo {
    UIColor* color = [UIColor redColor];
    return [color CGColor];
}
</code></p>

<p>Beware! It might crash at any time. Since we do not hold the reference of
UIColor, it would be released right after you create it! The CGColor it owns
would be released as well and thus cause a crash. There are three ways to fix
it:</p>

<ul>
  <li>Use <code>__autorelease</code> type qualifier. UIColor would be released at the end of
current run loop. It can fix the crash. I believe <a href="https://twitter.com/amattn">@amattn</a> is the first
one who discovered this solution.</li>
</ul>

<p><code>obj-c
- (CGColorRef)getFooColor {
    UIColor* __autoreleasing color = [UIColor redColor];
    return [color CGColor];
}
</code></p>

<ul>
  <li>Use Core Foundation naming convention and change the owner ship to the
 receiver.</li>
</ul>

<p>```obj-c
- (CGColorRef)fooColorCopy {
    UIColor* color = [UIColor redColor];
    CGColorRef c = CFRetain([color CGColor]);
    return c;
}</p>

<p>CGColorRef c = [obj fooColorCopy];
// do stuffs
CFRelease(c);
```</p>

<ul>
  <li>Owns the CF object by self. If self is dealloced, the reference would still
cause a crash.</li>
</ul>

<p><code>obj-c
- (CGColorRef)getFooColor {
    CGColorRef c = self.myColor.CGColor;
    return c;
}
</code></p>

<h2 id="pitfalls-in-block-and-arc">Pitfalls in block and ARC</h2>

<p>When you use a ivar in self owned block, it will implicitly contain self in your
block and thus cause a retain cycle:</p>

<p>```obj-c
@interface MyClass {
    id child;
}
@property (nonatomic, strong) (void(^)(void)) job;
@end</p>

<p>@implementation MyClass
- (void)foo {
    self.job = ^{
        [child work];
        // will expand to [self-&gt;child work]
    };
}
```</p>

<p>The only way to implement this safely is to use weak reference of self, and
setup a strong reference to weak self only in the scope of this block. The
reason we need to use a strong reference in scope is weak reference can be zero
out at any time. We must claim we own the object when we are using it.</p>

<p><code>obj-c
- (void)foo {
    MyClass* __weak w_self = self;
    self.block = ^{
        MyClass* s_self = w_self; // self retained, but only in this scope!
        if (s_self) {
            [s_self-&gt;child work];
            // do other stuffs
        }
    };
}
</code></p>

<h2 id="pitfalls-in-nserror">Pitfalls in NSError</h2>

<p>If you are implementing methods that take NSError, be sure to use the correct
format of type qualifier!</p>

<p><code>obj-c
- (void)doStuffWithError:(NSError* __autoreleasing *)error; // correct
- (void)doStuffWithError:(__autoreleasing NSError **)error; // wrong!
</code></p>

<p>Actually, when you craete a NSError object, it is always best to declare it is
an autoreleasing object:</p>

<p><code>obj-c
NSError* __autoreleasing error = nil; // correct
__autoreleasing NSError* error = nil; // wrong
NSError* error = nil; // Will be corrected by clang
</code></p>

<h2 id="summary">Summary</h2>

<p>ARC is handy, but not easy. When you facing complex memory ownership model,
wrting some testing code to know how retain count being managed is still a
recommanded pactice.  The below snippet is how I test retain count when mixing
CF object, block, and objective-c object:</p>

<p>```obj-c
- (void)testCGColorRetainCount1
{
    CGColorRef s_ref;
    @autoreleasepool {
        UIColor * __autoreleasing shadowColor = [UIColor colorWithRed:0.12 green:0.12 blue:0.12 alpha:1.0];
        s_ref = shadowColor.CGColor;
        CFRetain(s_ref);
    }
    STAssertEquals(CFGetRetainCount(s_ref), 1L, @”retain count owned by us”);</p>

<pre><code>CGColorRef(^strangeBlock)(void) = ^{
    return CGColorCreateCopy(s_ref);
};

CGColorRef myCopy = strangeBlock();
STAssertEquals(CFGetRetainCount(s_ref), 2L, @"retain count owned by block and us");
CFRelease(s_ref);
STAssertEquals(CFGetRetainCount(s_ref), 1L, @"retain count owned by block");
STAssertEquals(CFGetRetainCount(myCopy), 1L, @"retain count owned by us");
CFRelease(myCopy); } ```
</code></pre>

<p>Hope these helps! Comments and sharing are welcome!</p>

<div class="footnotes">
  <ol>
    <li id="fn:foot">
      <p>I didn’t reference back to @amattn’s ARC best practices when I first
post this article.  I am really sorry that I didn’t do it and I really
appreciate his pioneer work. I couldn’t write this article without his awesome
collection of how to write good ARC code.<a href="#fnref:foot" rel="reference">&#8617;</a></p>
    </li>
    <li id="fn:foot2">
      <p>Thanks to Tinghui’s comment that <code>NSTimer</code> should not be invalidated in
dealloc. <code>NSTimer</code> retains its target, so one should  use weak references if
the timer is a member of target’s property, else just leave it is fine.<a href="#fnref:foot2" rel="reference">&#8617;</a></p>
    </li>
  </ol>
</div>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Dance with Objective-C dynamic types]]></title>
    <link href="http://www.idryman.org/blog/2012/10/30/dance-with-objective-c-dynamic-types/"/>
    <updated>2012-10-30T13:58:00-07:00</updated>
    <id>http://www.idryman.org/blog/2012/10/30/dance-with-objective-c-dynamic-types</id>
    <content type="html"><![CDATA[<p>Objective-C is a super set of C language. The entire language is a preprocessor
skin added to C language and a powerful runtime system. With this runtime system,
one can have full featured object oriented programming interface, functional
programming environment, and magical dynamic typing system. </p>

<p>In this post, I’ll go through common tasks you can do with Objective-C typing
system, including querying normal <code>NSObject</code> types, packing static type with
<code>NSValue</code>, testing core foundation references, and validating if a pointer is a
valid object pointer.</p>

<!-- more -->

<h2 id="objective-c-type-system">Objective-C type system</h2>

<p>To determine an Objective-C object type is super easy. Just use <code>isKindOfClass</code>
method and it is done.</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">testObjectType:</span><span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="nv">obj</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">([</span><span class="n">obj</span> <span class="nl">isKindOfClass:</span> <span class="p">[</span><span class="n">NSNumber</span> <span class="n">class</span><span class="p">]])</span> <span class="p">{</span>
</span><span class='line'>        <span class="c1">// do something with number</span>
</span><span class='line'>    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">([</span><span class="n">obj</span> <span class="nl">isKindOfClass:</span> <span class="p">[</span><span class="n">NSValue</span> <span class="n">class</span><span class="p">])</span> <span class="p">{</span>
</span><span class='line'>        <span class="c1">// do something with values…</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>Why do we need this mechanism? One application is implementing key value coding
with some known range of types. For example, Core Animation listed these
properties are animatable:</p>

<ul>
  <li>anchorPoint</li>
  <li>backgroundColor</li>
  <li>backgroundFilters</li>
  <li>borderColor</li>
  <li>borderWidth</li>
  <li>bounds</li>
  <li>compositingFilter</li>
  <li>contents</li>
  <li>contentsRect</li>
  <li>cornerRadius</li>
  <li>doubleSided</li>
  <li>filters</li>
  <li>frame</li>
  <li>hidden</li>
  <li>mask</li>
  <li>masksToBounds</li>
  <li>opacity</li>
  <li>position</li>
  <li>shadowColor</li>
  <li>shadowOffset</li>
  <li>shadowOpacity</li>
  <li>shadowRadius</li>
  <li>sublayers</li>
  <li>sublayerTransform</li>
  <li>transform</li>
  <li>zPosition</li>
</ul>

<p>These properties are categorized in several types includes <code>CGPoint</code>, <code>CGRect</code>,
<code>CGFloat</code>, <code>CGImageRef</code>, <code>CGColorRef</code>, and even <code>BOOL</code>. Each kind of type
require individual implementation to operate its value. Thankfully,
Objective C dynamic type system allows us to pass-in the value with generic type
<code>id</code> and determine the actual type at runtime. <code>id</code> is simply a void
pointer. The objective c object itself is a struct which have a <code>isa</code> pointer
points to actual class which defines its instance variables, methods, and class
inheritances.</p>

<h2 id="packaging-static-c-types-with-nsvalue">Packaging static C types with NSValue</h2>

<p>Objective C is a skin language based on C, so it is very often to use C types
like int, float, pointer to struct…etc. However, these static types violate
Objective-C’s dynamic typing idioms. Apple introduced <code>NSValue</code> as a container
for a single C or Objective-C data item. It can hold any C types such as int,
float, char, pointers, structures, and object ids. It not only wrap the item
into an Objective-C object, but also encode the type information of the original
object.</p>

<p>To create an <code>NSValue</code> object, you pass it a pointer to the item, along with the
encoded type information generated by <code>@encode()</code> keyword.</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">CGPoint</span> <span class="n">origin</span> <span class="o">=</span> <span class="n">CGPointMake</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">);</span>
</span><span class='line'><span class="n">NSValue</span> <span class="o">*</span> <span class="n">originValue</span> <span class="o">=</span> <span class="p">[</span><span class="n">NSValue</span> <span class="nl">valueWithBytes:</span><span class="o">&amp;</span><span class="n">amp</span><span class="p">;</span><span class="n">origin</span> <span class="nl">objCType:</span><span class="k">@encode</span><span class="p">(</span><span class="n">CGPoint</span><span class="p">)];</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p><code>@encode()</code> is a compiler directive which can accepts all types that can be used
as an argument of C <code>sizeof()</code> operator. <code>@encode()</code> returns a <code>const char*</code>
string encoding that type. The encoding is specified in 
<a href="https://developer.apple.com/library/mac/#documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtTypeEncodings.html#//apple_ref/doc/uid/TP40008048-CH100">Objective-C runtime type encodings</a>.</p>

<p>To illustrate this, see the following examples:</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="err">@</span><span class="n">encoding</span><span class="p">(</span><span class="kt">int</span> <span class="o">**</span> <span class="p">)</span>
</span><span class='line'><span class="c1">// ==&amp;gt; “{^^i}”</span>
</span><span class='line'><span class="err">@</span><span class="n">encoding</span><span class="p">(</span><span class="n">CGPoint</span><span class="p">)</span>
</span><span class='line'><span class="c1">// ==&amp;gt; “{CGPoint=ff}”</span>
</span><span class='line'><span class="err">@</span><span class="n">encoding</span><span class="p">(</span><span class="n">CGColorRef</span><span class="p">)</span>
</span><span class='line'><span class="c1">// ==&amp;gt; “^{CGColor=}”</span>
</span><span class='line'><span class="err">@</span><span class="n">encoding</span><span class="p">(</span><span class="n">NSObject</span><span class="p">)</span>
</span><span class='line'><span class="c1">// ==&amp;gt; “{NSObject=#}”</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>With this encoded type information, it only takes few steps to determine which
type it is at runtime:</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">if</span> <span class="p">([</span><span class="n">obj</span> <span class="nl">isKindOfClass:</span><span class="p">[</span><span class="n">NSValue</span> <span class="n">class</span><span class="p">]])</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">NSValue</span><span class="o">*</span> <span class="n">value</span> <span class="o">=</span> <span class="p">(</span><span class="n">NSValue</span><span class="o">*</span><span class="p">)</span> <span class="n">obj</span><span class="p">;</span>
</span><span class='line'>    <span class="k">if</span> <span class="nf">strcmp</span><span class="p">([</span><span class="n">value</span> <span class="n">objCType</span><span class="p">],</span> <span class="k">@encode</span><span class="p">(</span><span class="n">CGPoint</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">CGPoint</span> <span class="n">origin</span><span class="p">;</span>
</span><span class='line'>        <span class="p">[</span><span class="n">value</span> <span class="nl">getValue:</span><span class="o">&amp;</span><span class="n">amp</span><span class="p">;</span><span class="n">origin</span><span class="p">];</span>
</span><span class='line'>        <span class="c1">// do things with origin…</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<h3 id="uikit-addition-to-nsvalue">UIKit addition to NSValue</h3>

<p>UIKit added a <a href="http://developer.apple.com/library/ios/#DOCUMENTATION/UIKit/Reference/NSValue_UIKit_Additions/Reference/Reference.html">category for NSValue</a> to represent iOS related
geometry-based data. You can use these method instead of encoding <code>CGPoint</code>,
<code>CGRect</code>, and else every time.</p>

<h2 id="bridging-with-core-foundation-objects">Bridging with Core Foundation objects</h2>

<p>Though <code>NSValue</code> covers many kind of types, in practice there are still some
types don’t fit this solution for dynamic typing. More specifically,
<code>CGColorRef</code>, <code>CGImageRef</code> and other Core Foundation types that can be treated
as Objective-C object through <a href="http://developer.apple.com/library/ios/#documentation/CoreFoundation/Conceptual/CFDesignConcepts/Articles/tollFreeBridgedTypes.html">toll-free briding</a> are the types we
don’t pack with <code>NSValue</code>.</p>

<p>A core foundation references is also a void pointer as same as <code>id</code> is.
To find out the type of an unknown <code>CFTypeRef</code>, you can query it with C function
<code>CFGetTypeID</code>.</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">if</span> <span class="p">(</span><span class="n">CFGetTypeID</span><span class="p">((</span><span class="n">__bridge</span> <span class="n">CFTypeRef</span><span class="p">)</span><span class="n">obj</span><span class="p">),</span> <span class="o">==</span> <span class="n">CGImageGetTypeID</span><span class="p">())</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">CGImageRef</span> <span class="n">imgRef</span> <span class="o">=</span> <span class="n">CFBridgingRetain</span><span class="p">(</span><span class="n">obj</span><span class="p">);</span>
</span><span class='line'>    <span class="c1">// do things with imgRef</span>
</span><span class='line'>    <span class="n">CFRelease</span><span class="p">(</span><span class="n">imgRef</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>A CFTypeRef marked as <code>id</code> type can also accept basic objective C messages like
<code>isKindOfType:</code>. Hence testing an <code>id</code> typed object is quite safe as long as it
is either a <code>NSObject</code>, <code>NSValue</code>, <code>CFTypeRef</code>, <code>CGColorRef</code> or any other
Objective-C object/Core Foundation reference.</p>

<h2 id="testing-if-a-pointer-is-a-valid-nsobject">Testing if a pointer is a valid NSObject</h2>

<p>There is a blog post on Cocoa with love about
<a href="http://www.cocoawithlove.com/2010/10/testing-if-arbitrary-pointer-is-valid.html">how to test if an arbitary pointer is a valid NSObject</a>.
In my point of view, programmer <em>should</em> pass in a valid object for sure. If it
is not a valid object, just let it crash.</p>

<h2 id="puting-it-all-together">Puting it all together</h2>

<p>This piece of code is part of my project <a href="https://github.com/dryman/FCAnimationFactory">FCAnimationFactory</a> for the
purpose of interpolating different kinds of value with respect to their types.</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><figcaption><span>FCAnimationFactory.m  </span><a href='https://github.com/dryman/FCAnimationFactory/blob/master/FCEasingAnimation/FCAnimationFactory.m'>link</a></figcaption> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
<span class='line-number'>72</span>
<span class='line-number'>73</span>
<span class='line-number'>74</span>
<span class='line-number'>75</span>
<span class='line-number'>76</span>
<span class='line-number'>77</span>
<span class='line-number'>78</span>
<span class='line-number'>79</span>
<span class='line-number'>80</span>
<span class='line-number'>81</span>
<span class='line-number'>82</span>
<span class='line-number'>83</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">-</span> <span class="p">(</span><span class="kt">id</span><span class="p">(</span><span class="o">^</span><span class="p">)(</span><span class="kt">float</span><span class="p">))</span><span class="nf">makeValueScalingBlockFromValue:</span><span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="nv">fromValue</span> <span class="nf">ToValue:</span><span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="nv">toValue</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="n">fromValue</span><span class="o">==</span><span class="nb">nil</span> <span class="o">||</span> <span class="n">toValue</span><span class="o">==</span><span class="nb">nil</span><span class="p">)</span> <span class="n">NSAssert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="err">@”</span><span class="n">fromValue</span> <span class="n">and</span> <span class="n">toValue</span> <span class="n">must</span> <span class="n">not</span> <span class="n">be</span> <span class="nb">nil</span><span class="err">”</span><span class="p">);</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="kt">id</span> <span class="n">value</span> <span class="o">=</span> <span class="n">fromValue</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="cm">/*</span>
</span><span class='line'><span class="cm"> * single float is handled in NSNumber</span>
</span><span class='line'><span class="cm"> */</span>
</span><span class='line'><span class="k">if</span> <span class="p">([</span><span class="n">value</span> <span class="nl">isKindOfClass:</span><span class="p">[</span><span class="n">NSNumber</span> <span class="n">class</span><span class="p">]])</span> <span class="p">{</span>
</span><span class='line'>    <span class="kt">float</span> <span class="n">v1</span> <span class="o">=</span> <span class="p">[(</span><span class="n">NSNumber</span><span class="o">*</span><span class="p">)</span><span class="n">fromValue</span> <span class="n">floatValue</span><span class="p">];</span>
</span><span class='line'>    <span class="kt">float</span> <span class="n">v2</span> <span class="o">=</span> <span class="p">[(</span><span class="n">NSNumber</span><span class="o">*</span><span class="p">)</span><span class="n">toValue</span> <span class="n">floatValue</span><span class="p">];</span>
</span><span class='line'>    <span class="kt">float</span> <span class="n">diffValue</span> <span class="o">=</span> <span class="n">v2</span> <span class="o">-</span> <span class="n">v1</span><span class="p">;</span>
</span><span class='line'>    <span class="k">return</span> <span class="o">^</span><span class="kt">id</span><span class="p">(</span><span class="kt">float</span> <span class="n">factor</span><span class="p">){</span>
</span><span class='line'>        <span class="kt">float</span> <span class="n">result</span> <span class="o">=</span> <span class="n">factor</span><span class="o">*</span><span class="n">diffValue</span> <span class="o">+</span> <span class="n">v1</span><span class="p">;</span>
</span><span class='line'>        <span class="k">return</span> <span class="p">[</span><span class="n">NSNumber</span> <span class="nl">numberWithFloat:</span><span class="n">result</span><span class="p">];</span>
</span><span class='line'>    <span class="p">};</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="cm">/*</span>
</span><span class='line'><span class="cm"> * NSValue handles CGPoint, CGSize, CGRect, and CATransform3D</span>
</span><span class='line'><span class="cm"> */</span>
</span><span class='line'><span class="k">if</span> <span class="p">([</span><span class="n">value</span> <span class="nl">isKindOfClass:</span><span class="p">[</span><span class="n">NSValue</span> <span class="n">class</span><span class="p">]])</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">objCType</span> <span class="o">=</span> <span class="p">[</span><span class="n">value</span> <span class="n">objCType</span><span class="p">];</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="n">strcmp</span><span class="p">(</span><span class="n">objCType</span><span class="p">,</span> <span class="k">@encode</span><span class="p">(</span><span class="n">CGPoint</span><span class="p">))</span><span class="o">==</span><span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">CGPoint</span> <span class="n">pt0</span><span class="p">,</span> <span class="n">pt1</span><span class="p">;</span>
</span><span class='line'>        <span class="p">[(</span><span class="n">NSValue</span><span class="o">*</span><span class="p">)</span><span class="n">fromValue</span> <span class="nl">getValue:</span><span class="o">&amp;</span><span class="n">amp</span><span class="p">;</span><span class="n">pt0</span><span class="p">];</span>
</span><span class='line'>        <span class="p">[(</span><span class="n">NSValue</span><span class="o">*</span><span class="p">)</span><span class="n">toValue</span> <span class="nl">getValue:</span><span class="o">&amp;</span><span class="n">amp</span><span class="p">;</span><span class="n">pt1</span><span class="p">];</span>
</span><span class='line'>        <span class="k">return</span> <span class="o">^</span><span class="kt">id</span><span class="p">(</span><span class="kt">float</span> <span class="n">factor</span><span class="p">){</span>
</span><span class='line'>            <span class="kt">float</span> <span class="n">x</span> <span class="o">=</span> <span class="p">(</span><span class="n">pt1</span><span class="p">.</span><span class="n">x</span> <span class="o">-</span> <span class="n">pt0</span><span class="p">.</span><span class="n">x</span><span class="p">)</span><span class="o">*</span><span class="n">factor</span> <span class="o">+</span> <span class="n">pt0</span><span class="p">.</span><span class="n">x</span><span class="p">;</span>
</span><span class='line'>            <span class="kt">float</span> <span class="n">y</span> <span class="o">=</span> <span class="p">(</span><span class="n">pt1</span><span class="p">.</span><span class="n">y</span> <span class="o">-</span> <span class="n">pt0</span><span class="p">.</span><span class="n">y</span><span class="p">)</span><span class="o">*</span><span class="n">factor</span> <span class="o">+</span> <span class="n">pt0</span><span class="p">.</span><span class="n">y</span><span class="p">;</span>
</span><span class='line'>            <span class="k">return</span> <span class="p">[</span><span class="n">NSValue</span> <span class="nl">valueWithCGPoint:</span><span class="n">CGPointMake</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)];</span>
</span><span class='line'>        <span class="p">};</span>
</span><span class='line'>    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">strcmp</span><span class="p">(</span><span class="n">objCType</span><span class="p">,</span> <span class="k">@encode</span><span class="p">(</span><span class="n">CGSize</span><span class="p">))</span><span class="o">==</span><span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">CGSize</span> <span class="n">size0</span><span class="p">,</span> <span class="n">size1</span><span class="p">;</span>
</span><span class='line'>        <span class="p">[(</span><span class="n">NSValue</span><span class="o">*</span><span class="p">)</span><span class="n">fromValue</span> <span class="nl">getValue:</span><span class="o">&amp;</span><span class="n">amp</span><span class="p">;</span><span class="n">size0</span><span class="p">];</span>
</span><span class='line'>        <span class="p">[(</span><span class="n">NSValue</span><span class="o">*</span><span class="p">)</span><span class="n">toValue</span> <span class="nl">getValue:</span><span class="o">&amp;</span><span class="n">amp</span><span class="p">;</span><span class="n">size1</span><span class="p">];</span>
</span><span class='line'>        <span class="k">return</span> <span class="o">^</span><span class="kt">id</span><span class="p">(</span><span class="kt">float</span> <span class="n">factor</span><span class="p">){</span>
</span><span class='line'>            <span class="kt">float</span> <span class="n">w</span> <span class="o">=</span> <span class="p">(</span><span class="n">size1</span><span class="p">.</span><span class="n">width</span> <span class="o">-</span> <span class="n">size0</span><span class="p">.</span><span class="n">width</span><span class="p">)</span><span class="o">*</span><span class="n">factor</span> <span class="o">+</span> <span class="n">size0</span><span class="p">.</span><span class="n">width</span><span class="p">;</span>
</span><span class='line'>            <span class="kt">float</span> <span class="n">h</span> <span class="o">=</span> <span class="p">(</span><span class="n">size1</span><span class="p">.</span><span class="n">height</span> <span class="o">-</span> <span class="n">size0</span><span class="p">.</span><span class="n">height</span><span class="p">)</span><span class="o">*</span><span class="n">factor</span> <span class="o">+</span> <span class="n">size0</span><span class="p">.</span><span class="n">height</span><span class="p">;</span>
</span><span class='line'>            <span class="k">return</span> <span class="p">[</span><span class="n">NSValue</span> <span class="nl">valueWithCGSize:</span><span class="n">CGSizeMake</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="n">h</span><span class="p">)];</span>
</span><span class='line'>        <span class="p">};</span>
</span><span class='line'>    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">strcmp</span><span class="p">(</span><span class="n">objCType</span><span class="p">,</span> <span class="k">@encode</span><span class="p">(</span><span class="n">CGRect</span><span class="p">))</span><span class="o">==</span><span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">CGRect</span> <span class="n">rect0</span><span class="p">,</span> <span class="n">rect1</span><span class="p">;</span>
</span><span class='line'>        <span class="p">[(</span><span class="n">NSValue</span><span class="o">*</span><span class="p">)</span><span class="n">fromValue</span> <span class="nl">getValue:</span><span class="o">&amp;</span><span class="n">amp</span><span class="p">;</span><span class="n">rect0</span><span class="p">];</span>
</span><span class='line'>        <span class="p">[(</span><span class="n">NSValue</span><span class="o">*</span><span class="p">)</span><span class="n">toValue</span> <span class="nl">getValue:</span><span class="o">&amp;</span><span class="n">amp</span><span class="p">;</span><span class="n">rect1</span><span class="p">];</span>
</span><span class='line'>        <span class="k">return</span> <span class="o">^</span><span class="kt">id</span><span class="p">(</span><span class="kt">float</span> <span class="n">factor</span><span class="p">){</span>
</span><span class='line'>            <span class="kt">float</span> <span class="n">x</span> <span class="o">=</span> <span class="p">(</span><span class="n">rect1</span><span class="p">.</span><span class="n">origin</span><span class="p">.</span><span class="n">x</span> <span class="o">-</span> <span class="n">rect0</span><span class="p">.</span><span class="n">origin</span><span class="p">.</span><span class="n">x</span><span class="p">)</span><span class="o">*</span><span class="n">factor</span> <span class="o">+</span> <span class="n">rect0</span><span class="p">.</span><span class="n">origin</span><span class="p">.</span><span class="n">x</span><span class="p">;</span>
</span><span class='line'>            <span class="kt">float</span> <span class="n">y</span> <span class="o">=</span> <span class="p">(</span><span class="n">rect1</span><span class="p">.</span><span class="n">origin</span><span class="p">.</span><span class="n">y</span> <span class="o">-</span> <span class="n">rect0</span><span class="p">.</span><span class="n">origin</span><span class="p">.</span><span class="n">y</span><span class="p">)</span><span class="o">*</span><span class="n">factor</span> <span class="o">+</span> <span class="n">rect0</span><span class="p">.</span><span class="n">origin</span><span class="p">.</span><span class="n">y</span><span class="p">;</span>
</span><span class='line'>            <span class="kt">float</span> <span class="n">w</span> <span class="o">=</span> <span class="p">(</span><span class="n">rect1</span><span class="p">.</span><span class="n">size</span><span class="p">.</span><span class="n">width</span> <span class="o">-</span> <span class="n">rect0</span><span class="p">.</span><span class="n">size</span><span class="p">.</span><span class="n">width</span><span class="p">)</span><span class="o">*</span><span class="n">factor</span> <span class="o">+</span> <span class="n">rect0</span><span class="p">.</span><span class="n">size</span><span class="p">.</span><span class="n">width</span><span class="p">;</span>
</span><span class='line'>            <span class="kt">float</span> <span class="n">h</span> <span class="o">=</span> <span class="p">(</span><span class="n">rect1</span><span class="p">.</span><span class="n">size</span><span class="p">.</span><span class="n">height</span> <span class="o">-</span> <span class="n">rect0</span><span class="p">.</span><span class="n">size</span><span class="p">.</span><span class="n">height</span><span class="p">)</span><span class="o">*</span><span class="n">factor</span> <span class="o">+</span> <span class="n">rect0</span><span class="p">.</span><span class="n">size</span><span class="p">.</span><span class="n">height</span><span class="p">;</span>
</span><span class='line'>            <span class="k">return</span> <span class="p">[</span><span class="n">NSValue</span> <span class="nl">valueWithCGRect:</span><span class="n">CGRectMake</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">h</span><span class="p">)];</span>
</span><span class='line'>        <span class="p">};</span>
</span><span class='line'>    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">strcmp</span><span class="p">(</span><span class="n">objCType</span><span class="p">,</span> <span class="k">@encode</span><span class="p">(</span><span class="n">CATransform3D</span><span class="p">))</span><span class="o">==</span><span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">NSAssert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">@&quot;CATransform3D type currently not supported&quot;</span><span class="p">);</span>
</span><span class='line'>    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">NSAssert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">@&quot;Unknown NSValue type %s&quot;</span><span class="p">,</span><span class="n">objCType</span><span class="p">);</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">if</span> <span class="p">(</span><span class="n">CFGetTypeID</span><span class="p">((</span><span class="n">__bridge</span> <span class="n">CFTypeRef</span><span class="p">)</span><span class="n">value</span><span class="p">)</span> <span class="o">==</span> <span class="n">CGColorGetTypeID</span><span class="p">())</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="o">^</span><span class="kt">id</span><span class="p">(</span><span class="kt">float</span> <span class="n">factor</span><span class="p">){</span>
</span><span class='line'>        <span class="n">CGColorRef</span> <span class="n">fromColor</span> <span class="o">=</span> <span class="p">(</span><span class="n">__bridge</span> <span class="n">CGColorRef</span><span class="p">)</span><span class="n">fromValue</span><span class="p">;</span>
</span><span class='line'>        <span class="n">CGColorRef</span> <span class="n">toColor</span> <span class="o">=</span> <span class="p">(</span><span class="n">__bridge</span> <span class="n">CGColorRef</span><span class="p">)</span><span class="n">toValue</span><span class="p">;</span>
</span><span class='line'>        <span class="n">size_t</span> <span class="n">num</span> <span class="o">=</span> <span class="n">CGColorGetNumberOfComponents</span><span class="p">(</span><span class="n">fromColor</span><span class="p">);</span>
</span><span class='line'>        <span class="k">const</span> <span class="n">CGFloat</span> <span class="o">*</span><span class="n">fromComp</span> <span class="o">=</span> <span class="n">CGColorGetComponents</span><span class="p">(</span><span class="n">fromColor</span><span class="p">);</span>
</span><span class='line'>        <span class="k">const</span> <span class="n">CGFloat</span> <span class="o">*</span><span class="n">toComp</span> <span class="o">=</span> <span class="n">CGColorGetComponents</span><span class="p">(</span><span class="n">toColor</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>        <span class="n">CGFloat</span> <span class="n">newComp</span><span class="p">[</span><span class="n">num</span><span class="p">];</span> <span class="c1">// same as malloca</span>
</span><span class='line'>        <span class="k">for</span> <span class="p">(</span><span class="n">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span> <span class="n">num</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>            <span class="n">newComp</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">toComp</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">fromComp</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">*</span> <span class="n">factor</span> <span class="o">+</span> <span class="n">fromComp</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>        <span class="n">CGColorRef</span> <span class="n">retColor</span> <span class="o">=</span> <span class="n">CGColorCreate</span><span class="p">(</span><span class="n">CGColorGetColorSpace</span><span class="p">(</span><span class="n">fromColor</span><span class="p">),</span> <span class="n">newComp</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>        <span class="k">return</span> <span class="p">(</span><span class="n">__bridge_transfer</span> <span class="kt">id</span><span class="p">)</span><span class="n">retColor</span><span class="p">;</span>
</span><span class='line'>    <span class="p">};</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="k">if</span> <span class="p">(</span><span class="n">CFGetTypeID</span><span class="p">((</span><span class="n">__bridge</span> <span class="n">CFTypeRef</span><span class="p">)</span><span class="n">value</span><span class="p">)</span> <span class="o">==</span> <span class="n">CGImageGetTypeID</span><span class="p">())</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">NSAssert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">@&quot;CGImageRef should be handled in another class&quot;</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="n">NSAssert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">@&quot;value type unknown&quot;</span><span class="p">);</span>
</span><span class='line'><span class="k">return</span> <span class="o">^</span><span class="kt">id</span><span class="p">(</span><span class="kt">float</span> <span class="n">factor</span><span class="p">){</span> <span class="k">return</span> <span class="nb">nil</span><span class="p">;};</span>    <span class="c1">// turn off compiler warnings } </span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
</code></pre>

<h2 id="conclusion">Conclusion</h2>

<p>It is amazing that a langauge so close to C can create such a rich type system
without byte code, VM, or complex sybol tricks (like what C++ does). Though
handling differnt types can be a bit painful sometimes, but it brings powerful
polimorphsm to the language. Thus programmer can create highly abstract API
and framework with differnt data types that share the same methods.</p>

<h2 id="references">References</h2>

<ul>
  <li><a href="http://www.cocoawithlove.com/2010/10/testing-if-arbitrary-pointer-is-valid.html">how to test if an arbitary pointer is a valid NSObject</a></li>
  <li><a href="https://developer.apple.com/library/mac/#documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtTypeEncodings.html#//apple_ref/doc/uid/TP40008048-CH100">Objective C type encoding</a></li>
  <li><a href="http://developer.apple.com/library/mac/#documentation/CoreFoundation/Conceptual/CFDesignConcepts/Articles/Inspecting.html">Inspecting core foundation object</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Type Qualifiers and friends]]></title>
    <link href="http://www.idryman.org/blog/2012/10/29/type-qualifiers/"/>
    <updated>2012-10-29T08:55:00-07:00</updated>
    <id>http://www.idryman.org/blog/2012/10/29/type-qualifiers</id>
    <content type="html"><![CDATA[<p>Type qualifiers are heavily used in C and Objective C. In C99 there are three
type qualifiers: <code>const</code>, <code>restrict</code>, and <code>volatile</code>. In objective C,
Apple introduced <code>__weak</code>, <code>__strong</code>, <code>__unsafe_unretained</code>, and
<code>__autoreleasing</code> for automatic reference counting.</p>

<p>It is easy to get confused with complicated type qualifiers. For example:</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="kt">char</span><span class="o">*</span> <span class="k">const</span> <span class="o">*</span> <span class="n">x</span><span class="p">;</span>  <span class="c1">// x is a pointer to const pointer to char</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>In this post I’ll go through what type qualifiers are, and how do we read and
write it in correct way.</p>

<!-- more -->

<h2 id="names-and-definitions">Names and definitions</h2>

<p>Type qualifiers should not be confused with <strong>storage specifiers</strong> like <code>static</code>
<code>auto</code>, <code>extern</code> and <code>register</code>. To illustrate this, allow me to use Mike Ash’s
example:</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="k">static</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">x</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>Here, <code>static</code> is a storage specifier to tell complier how <code>x</code> is stored, and
<code>const</code> is a type qualifier to tell complier <strong>the type</strong> of x is read-only
data. Since <code>const</code> is part of the type, you can write:</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="k">typedef</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">MyInt</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>but you cannot write:</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="k">typedef</span> <span class="k">static</span> <span class="kt">int</span> <span class="n">MyInt</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>This is because <code>static</code> is not part of the type.</p>

<p>You might wonder: is <code>__block</code> a type qualifier or storage specifier?  The 
<a href="http://clang.llvm.org/docs/BlockLanguageSpec.txt">clang block language spec</a> said that it is a <strong>storage qualifier</strong>.
Don’t get confused.  <code>__block</code> is a <em>storage qualifer/specifer</em> which modifies
how variable is stored.  For more curious on <code>__block</code>, you can check out my
previous post <a href="http://www.idryman.org/blog/2012/09/29/c-objc-block-byref-internals/">Block byref internals</a>.</p>

<h3 id="arc-ownership-qualifiers">ARC ownership qualifiers</h3>

<p>What about <code>__strong</code>, <code>__weak</code>, <code>__unsafe_unretained</code>, and <code>__autoreleasing</code>?
You <em>can</em> use it with <code>typedef</code>, and they are truly part of the type. However, they
are a bit different from C type qualifiers. ARC generated code have an runtime
API supports it. You can manually use some of those: <code>objc_storeWeak</code>,
<code>objc_destroyWeak</code>…etc. In Clang specification, these qualifiers are named
<strong>ownership qualifiers</strong>. Luckily, they share the same rule of type
qualifiers.</p>

<h2 id="the-grammar">The grammar</h2>

<p>C declaration can be really complicated. In this section I’ll just cover the
basics and the most commonly seen ones.</p>

<ul>
  <li>Rule 1: find the identifier (the variable), read from right to left.</li>
</ul>

<p><div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="kt">int</span> <span class="n">x</span><span class="p">;</span>                <span class="c1">// x is int</span>
</span><span class='line'><span class="kt">int</span> <span class="o">*</span> <span class="n">x</span><span class="p">;</span>              <span class="c1">// x is a ‘pointer to’ int</span>
</span><span class='line'><span class="kt">int</span> <span class="o">*</span> <span class="o">*</span> <span class="n">x</span><span class="p">;</span>            <span class="c1">// x is a ‘pointer to’ ‘pointer to’ int</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>When there is a type qualifier, it applies to its immediate left:</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="kt">int</span> <span class="k">const</span> <span class="n">x</span><span class="p">;</span>          <span class="c1">// x is a const int</span>
</span><span class='line'><span class="kt">int</span> <span class="o">*</span> <span class="k">const</span> <span class="n">x</span><span class="p">;</span>        <span class="c1">// x is a ‘const pointer to’ int</span>
</span><span class='line'><span class="kt">int</span> <span class="k">const</span> <span class="o">*</span> <span class="n">x</span><span class="p">;</span>        <span class="c1">// x is a ‘pointer to’ const int</span>
</span><span class='line'><span class="kt">int</span> <span class="o">*</span> <span class="k">const</span> <span class="o">*</span> <span class="n">x</span><span class="p">;</span>      <span class="c1">// x is a ‘pointer to’ ‘const pointer to’ int</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<ul>
  <li>Rule 2: If next to type specifier, it applies to type-specifier</li>
</ul>

<p><div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="k">const</span> <span class="kt">int</span> <span class="n">x</span><span class="p">;</span>          <span class="c1">// x is a const int</span>
</span><span class='line'><span class="k">const</span> <span class="kt">int</span> <span class="o">*</span> <span class="k">const</span> <span class="n">x</span><span class="p">;</span>  <span class="c1">// x is a ‘const pointer to’ const int</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<ul>
  <li>Rule 3: If there are parenthesis or bracelets, reorder it to postfix form:</li>
</ul>

<p><div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="kt">int</span> <span class="o">*</span> <span class="k">const</span> <span class="o">*</span> <span class="p">(</span> <span class="o">*</span> <span class="n">p</span><span class="p">)();</span>
</span><span class='line'><span class="c1">// postfix: p * () * const * int</span>
</span><span class='line'><span class="c1">// p is a pointer to a function returning a</span>
</span><span class='line'><span class="c1">// pointer to const-pointer-to-int</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>For more curious, checkout <a href="http://www.vineetgupta.com/2011/03/deciphering-complex-c-declarations/">Deciphering Complex C Declarations</a> and
<a href="http://cdecl.org">cdecl</a>.</p>

<h2 id="volatile-restrict">volatile, restrict</h2>

<h3 id="volatile">volatile</h3>

<blockquote>
  <p>Every reference to the variable will reload the contents from memory rather
than take advantage of situations where a copy can be in a register.</p>
</blockquote>

<p>The <code>volatile</code> qualifier maintains consistency of memory access to data objects.
Volatile variable are read from memory each time their values is needed, and
writen back to memory each time they are changed. However, volatile variables
are not automic. If you want to write thread safe operation, you can write
something like:</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><figcaption><span>OSAtomic.h </span><a href='http://www.opensource.apple.com/source/xnu/xnu-1456.1.26/libkern/libkern/OSAtomic.h'>link</a></figcaption> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="k">static</span> <span class="kr">__inline</span> <span class="n">bool</span> <span class="nf">OSAtomicCompareAndSwapInt</span><span class="p">(</span><span class="kt">int</span> <span class="n">oldi</span><span class="p">,</span> <span class="kt">int</span> <span class="n">newi</span><span class="p">,</span> <span class="kt">int</span> <span class="k">volatile</span> <span class="o">*</span><span class="n">dst</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="kt">int</span> <span class="n">original</span> <span class="o">=</span> <span class="n">InterlockedCompareExchange</span><span class="p">(</span><span class="n">dst</span><span class="p">,</span> <span class="n">newi</span><span class="p">,</span> <span class="n">oldi</span><span class="p">);</span>
</span><span class='line'>    <span class="k">return</span> <span class="p">(</span><span class="n">original</span> <span class="o">==</span> <span class="n">oldi</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>This is a function that is thread and multiprocessor safe to swap/update an integer.
Objective-C runtime uses these functions defined in <a href="http://www.opensource.apple.com/source/xnu/xnu-1456.1.26/libkern/libkern/OSAtomic.h">OSAtomic.h</a> to
manage retain counts.</p>

<h3 id="restrict">restrict</h3>

<p><code>restrict</code> is a keyword purely for the purpose of optimization. </p>

<blockquote>
  <p>In the C programming language, as of the C99 standard, restrict is a keyword
that can be used in pointer declarations. The restrict keyword is a
declaration of intent given by the programmer to the compiler. It says that
for the lifetime of the pointer, only it or a value directly derived from it
(such as <code>pointer + 1</code>) will be used to access the object to which
it points. This limits the effects of pointer aliasing, aiding caching
optimizations.</p>
</blockquote>

<p><code>restrict</code> is a qualifier for pointers. It claims that the memory that pointer
points to can only be accessed by this pointer.  Consider this case:</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="kt">char</span> <span class="o">*</span><span class="n">src</span><span class="p">,</span> <span class="o">*</span><span class="n">dst</span><span class="p">;</span>
</span><span class='line'><span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span> <span class="n">len</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
</span><span class='line'>    <span class="n">dst</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">src</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>If the <code>*dst</code> overlapped with <code>*src</code>, compiler can only generate code that load a
small piece of memory and operate it once at a time. Fortran does not have this
problem because it does not have pointers. Thus Fortran can do ambitious optimization
to load a big chunck of memory and operate it all at once. <code>restrict</code> is a new
keyword defined in C99 to address this problem. The original code can be
rewritten as:</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="kt">void</span> <span class="o">*</span><span class="n">memcpy</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="kr">restrict</span> <span class="n">s1</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="kr">restrict</span> <span class="n">s2</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">n</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>and compiler can optimize this code like Fortran does!</p>

<p>Note that <code>restrict</code> is a type qualifier for <strong>pointers</strong>.</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="kt">int</span> <span class="o">*</span> <span class="kr">restrict</span> <span class="n">x</span><span class="p">;</span> <span class="c1">// correct</span>
</span><span class='line'><span class="kt">int</span> <span class="kr">restrict</span> <span class="o">*</span> <span class="n">x</span><span class="p">;</span> <span class="c1">// wrong</span>
</span><span class='line'><span class="kr">restrict</span> <span class="kt">int</span> <span class="o">*</span> <span class="n">x</span><span class="p">;</span> <span class="c1">// wrong</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<h2 id="arc-ownership-qualifiers-1">ARC ownership qualifiers</h2>

<p>If you understand all the above, then Objective-C Automatic Reference Counting
qualifiers should be easy to you! Here is the definition from Apple:</p>

<ol>
  <li><code>__strong</code> is the default. An object remains <strong>alive</strong> as long as there is a strong
  pointer to it.</li>
  <li><code>__weak</code> specifies a reference that does not keep the referenced object alive. A
  weak reference is set to <code>nil</code> when there are no strong references to the object.</li>
  <li><code>__unsafe_unretained</code> specifies a reference that does not keep the referenced
  object alive and is not set to <code>nil</code> when there are no strong references to the
  object. If the object it references is deallocated, the pointer is left
  dangling.</li>
  <li><code>__autoreleasing</code> is used to denote arguments that are passed by reference <code>(id *)</code>
  and are autoreleased on return.</li>
</ol>

<p>All ownership qualifiers should decorate on Objective-C object pointers.</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">MyClass</span> <span class="o">*</span> <span class="n">__weak</span> <span class="n">_weakSelf</span> <span class="o">=</span> <span class="n">self</span><span class="p">;</span>    <span class="c1">// correct</span>
</span><span class='line'><span class="n">MyClass</span> <span class="n">__weak</span> <span class="o">*</span> <span class="n">_weakSelf</span> <span class="o">=</span> <span class="n">self</span><span class="p">;</span>    <span class="c1">// wrong! May cause serious bugs!</span>
</span><span class='line'><span class="n">__weak</span> <span class="n">MyClass</span> <span class="o">*</span> <span class="n">_weakSelf</span> <span class="o">=</span> <span class="n">self</span><span class="p">;</span>    <span class="c1">// wrong!&lt;/p&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="c1">// Explicitly transfer CGColorRef ownership from UIColor to layer’s backgroundColor</span>
</span><span class='line'><span class="n">CALayer</span><span class="o">*</span> <span class="n">layer</span> <span class="o">=</span> <span class="p">[</span><span class="n">CALayer</span> <span class="n">layer</span><span class="p">];</span>
</span><span class='line'><span class="n">CGColorRef</span> <span class="n">redRef</span><span class="p">;</span>
</span><span class='line'><span class="err">@</span><span class="n">autorelease</span><span class="p">{</span>
</span><span class='line'>    <span class="n">UIColor</span> <span class="o">*</span> <span class="n">__autoreleasing</span> <span class="n">redColor</span> <span class="o">=</span> <span class="p">[[</span><span class="n">UIColor</span> <span class="n">redColor</span><span class="p">]</span> <span class="nl">colorWithAlphaComponent:</span><span class="mf">.5f</span><span class="p">];</span>
</span><span class='line'>    <span class="n">redRef</span> <span class="o">=</span> <span class="n">CFRetain</span><span class="p">([</span><span class="n">redColor</span> <span class="n">CGColor</span><span class="p">]);</span>
</span><span class='line'><span class="p">}</span> <span class="c1">// UIColor released</span>
</span><span class='line'><span class="n">layer</span><span class="p">.</span><span class="n">backgroundColor</span> <span class="o">=</span> <span class="n">redRef</span><span class="p">;</span>
</span><span class='line'><span class="n">CFRelease</span><span class="p">(</span><span class="n">redRef</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>For more curious on why do we need to write verbose code for <code>CGColor</code>, you can
take a look at Big Nerd Ranch’s 
<a href="http://weblog.bignerdranch.com/296-arc-gotcha-unexpectedly-short-lifetimes/">ARC Gotcha – Unexpectedly Short Lifetimes</a> and Amatten’s
<a href="http://amattn.com/2011/12/07/arc_best_practices.html">ARC Best Practices</a>.</p>

<h2 id="references">References</h2>

<ul>
  <li><a href="http://www.vineetgupta.com/2011/03/deciphering-complex-c-declarations/">Deciphering complex c declarations</a></li>
  <li><a href="http://www.mikeash.com/pyblog/friday-qa-2009-06-26-type-qualifiers-in-c-part-1.html">Mike Ash Friday QA: Type qualifiers in C part 1</a></li>
  <li><a href="http://weblog.bignerdranch.com/296-arc-gotcha-unexpectedly-short-lifetimes/">ARC Gotcha – Unexpectedly Short Lifetimes</a> and Amatten’s</li>
  <li><a href="http://amattn.com/2011/12/07/arc_best_practices.html">ARC Best Practices</a></li>
  <li><a href="http://clang.llvm.org/docs/BlockLanguageSpec.txt">Block language spec</a></li>
  <li><a href="http://clang.llvm.org/docs/AutomaticReferenceCounting.html">Clang ARC spec</a></li>
  <li><a href="http://developer.apple.com/library/mac/#releasenotes/ObjectiveC/RN-TransitioningToARC/Introduction/Introduction.html">Transitioning to ARC Release Notes</a></li>
</ul>

]]></content>
  </entry>
  
</feed>
