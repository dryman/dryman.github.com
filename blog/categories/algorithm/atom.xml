<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Algorithm | Carpe diem (Felix's blog)]]></title>
  <link href="http://www.idryman.org/blog/categories/algorithm/atom.xml" rel="self"/>
  <link href="http://www.idryman.org/"/>
  <updated>2012-06-17T16:22:28+08:00</updated>
  <id>http://www.idryman.org/</id>
  <author>
    <name><![CDATA[dryman (Felix Ren-Chyan Chern)]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[persistent red black tree in lisp (4)]]></title>
    <link href="http://www.idryman.org/blog/2012/04/01/persistent-red-black-tree-4/"/>
    <updated>2012-04-01T14:48:00+08:00</updated>
    <id>http://www.idryman.org/blog/2012/04/01/persistent-red-black-tree-4</id>
    <content type="html"><![CDATA[<h3 id="okasakis-purely-functional-red-black-tree">Okasaki’s purely functional red black tree</h3>

<p>The peristent red black tree in last post works ok, but the rotate functions and
color flip is not efficient for purely functional data sturctures.
In 1999, Okasaki introduced a new way to balance the insertion, and the function
only takes care of four unbalanced cases.</p>

<pre><code>Chris Okasaki,
"Red-Black Trees in a Functional Setting",
Journal of Functional Programming, 9(4),
pp471-477,
July 1999
</code></pre>

<p>The algorithm is easy to present in Haskell code:</p>

<p>{% codeblock lang:hs Okasaki’s red black tree insertion http://www.mew.org/~kazu/proj/red-black-tree/ Copied from Kazu Yamamoto’s website%}
data RBTree a = Leaf | Fork Color (RBTree a) a (RBTree a)
data Color = R | B</p>

<p>insert :: Ord a =&gt; a -&gt; RBTree a -&gt; RBTree a
insert a b = Fork B d e f
  where
    Fork _ d e f = ins a b
    ins x Leaf = Fork R Leaf x Leaf
    ins x t@(Fork c l y r) = case compare x y of
        LT -&gt; balanceL c (ins x l) y r
        GT -&gt; balanceR c l y (ins x r)
        EQ -&gt; t</p>

<p>balanceL :: Color -&gt; RBTree a -&gt; a -&gt; RBTree a -&gt; RBTree a
balanceL B (Fork R (Fork R a x b) y c) z d = Fork R (Fork B a x b) y (Fork B c z d)
balanceL B (Fork R a x (Fork R b y c)) z d = Fork R (Fork B a x b) y (Fork B c z d)
balanceL k a x b                           = Fork k a x b</p>

<p>balanceR :: Color -&gt; RBTree a -&gt; a -&gt; RBTree a -&gt; RBTree a
balanceR B a x (Fork R b y (Fork R c z d)) = Fork R (Fork B a x b) y (Fork B c z d)
balanceR B a x (Fork R (Fork R b y c) z d) = Fork R (Fork B a x b) y (Fork B c z d)
balanceR k a x b 
{% endcodeblock %}</p>

<!-- more -->

<p>Cool! This can be even reduced to only two cases in our <code>mtree-expand</code> and
<code>mtree-let</code> macro!</p>

<p>{% codeblock lang:cl %}
(defun balance-o (root dir)
  (mtree-let dir root (a x (b y (c z d)))
             ((z-b (to-b z)))
             (mtree-expand dir ((a x b) y (c z-b d)))))</p>

<p>(defun balance-i (root dir)
  (mtree-let dir root (a x ((b z c) y d))
             ((y-b (to-b y)))
             (mtree-expand dir ((a x b) z (c y-b d)))))</p>

<p>(defun insert-oka (root data)
  (declare (type fixnum data))
  (cond ((null root) `(nil ,(make-rb :data data) nil))
        ((= (node-data root) data) root)
        (T (let* ((dir (&gt; data (node-data root)))
                 (a (kid root (not dir)))
                 (b (insert-oka (kid root dir) data))
                 (root (if dir (list a (cadr root) b) (list b (cadr root) a))))
            (cond ((is-red root) root)
                  ((and (is-red b) (is-red (kid b dir))) (balance-o root dir))
                  ((and (is-red b) (is-red (kid b (not dir)))) (balance-i root dir))
                  (T root))))))</p>

<p>(defparameter <em>tree</em> nil)
(defun rb-insert (data)
  (declare (type fixnum data))
  (setq <em>tree</em> (insert-oka <em>tree</em> data)))
{% endcodeblock %}</p>

<p>To test the running time:
{% codeblock lang:cl %}
(time (loop for i from 1 to 1000000 do (rb-insert i)))</p>

<p>;; The original algorithm using rotate-s and rotate-d
  19.796 seconds of real time
  18.570645 seconds of total run time (17.423563 user, 1.147082 system)
  [ Run times consist of 3.043 seconds GC time, and 15.528 seconds non-GC time. ]
  93.81% CPU
  47,299,915,377 processor cycles
  6,522,724,144 bytes consed</p>

<p>;; The Okasaki’s algorithm
  13.005 seconds of real time
  12.193227 seconds of total run time (11.213534 user, 0.979693 system)
  [ Run times consist of 2.513 seconds GC time, and 9.681 seconds non-GC time. ]
  93.76% CPU
  31,073,022,018 processor cycles
  4,278,336,384 bytes consed
{% endcodeblock %}</p>

<h2 id="conclusions">Conclusions</h2>

<p>Lisp is designed for bottom-up programming. You first draft what you want to do,
then you can start to write some functions and macros to simplify it. When there
are more and more utilities you written, you can use it to experiment more
complicated algorithms, in a more elegant and self expressive style.</p>

<p>In purely functional structure, Haskell code  seems to be more elegant because
it has built in pattern matching, while we have to write one for Lisp. But Lisp
provides things more than functional programming, it can also be written in
procedure style, object-oriented style, or any other DSL that is best suitable
for your objective.</p>

<p>The macro system in lisp can also improve your thinking of designing a program.
Because you can always abstract your program structure as you writing it. In
other language you are trained to think top-down, while in lisp you are
encouraged to think back and forth. This process can shorten required time to
get enough experiences of programming. You don’t need a lot experiences to build
a complex algorithm in a bottom-up design process. It’s just come up naturally.</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[persistent red black tree in lisp (3)]]></title>
    <link href="http://www.idryman.org/blog/2012/03/31/persistent-red-black-tree-in-lisp-3/"/>
    <updated>2012-03-31T16:33:00+08:00</updated>
    <id>http://www.idryman.org/blog/2012/03/31/persistent-red-black-tree-in-lisp-3</id>
    <content type="html"><![CDATA[<h2 id="red-black-tree-algorithms">Red black tree algorithms</h2>

<p>There are two good articles that have good explanation on red-black tree
algorithms. For your references:</p>

<ol>
  <li><a href="http://eternallyconfuzzled.com/tuts/datastructures/jsw_tut_rbtree.aspx">Julienne Walker’s red black tree tutorial</a></li>
  <li><a href="http://www.mew.org/~kazu/proj/red-black-tree/">Kazu Yamamoto’s purely functional left-leaning red black trees</a></li>
</ol>

<p>Julienne wrote a beautiful review article that show us not only the algorithm of
red black tree, but <em>how it is designed like so</em>. He also implemented an elegant
C program that can balance the tree in bottom-up or top-down ways. My previous
function <code>(kid root dir dir)</code> was inspired from his implementation.</p>

<p>Kazu reorganized several red black tree insertion algorithms, including Chris
Okasaki’s purely functional way. He also introduced a left-leaning insertion
algorithm that reduces one pattern matching compare to Okasaki’s one. The
programs are elegantly written in Haskell.</p>

<!-- more -->

<h3 id="orinal-red-black-tree-algorithm">Orinal red black tree algorithm</h3>

<p>In 1979, Guibas and Sedgewick published the original imperative red black trees:</p>

<pre><code>Leo J. Guibas and Robert Sedgewick.
"A dichromatic framework for balanced trees",
In Proceedings of the 19th Annual Symposium on Computer Science,
pp8-21,
IEEE Computer Society,
1978
</code></pre>

<p>The original one has eight <em>unbalanced</em> cases to deal with, while two are
reduced in “Introduction to Algorithms”. The algorithm was derived from
symmetric binary B-tree (2-3-4 tree) which was suggested by Rudof Bayer. All
paths from the root to a leaf in a SBB-tree contains the same number of nodes,
thus make it a perfectly balanced tree. However, it is not a binary search tree.
So Rober Sedgewick and Leonidas Guibas came up with a mnemonic abstraction that
can use red-nodes and black-nodes of a binary tree to simulate SBB-Tree. This is
how the algorithm is formed. To know the details, see 
<a href="http://eternallyconfuzzled.com/tuts/datastructures/jsw_tut_rbtree.aspx">Julienne’s guide</a>.</p>

<p>Julienne modified the original bottom up algorithm to a no parent pointers
style:</p>

<p>{% codeblock Julienne’s red black tree insert implementation lang:c %}
struct jsw_node *jsw_single ( struct jsw_node *root, int dir )
{
  struct jsw_node *save = root-&gt;link[!dir];</p>

<p>root-&gt;link[!dir] = save-&gt;link[dir];
  save-&gt;link[dir] = root;</p>

<p>root-&gt;red = 1;  // Note that there’s color changing here!
  save-&gt;red = 0;</p>

<p>return save;
}</p>

<p>struct jsw_node *jsw_double ( struct jsw_node *root, int dir )
{
  root-&gt;link[!dir] = jsw_single ( root-&gt;link[!dir], !dir );
  return jsw_single ( root, dir );
}</p>

<p>struct jsw_node *jsw_insert_r ( struct jsw_node *root, int data )
{
  if ( root == NULL )
    root = make_node ( data );
  else if ( data != root-&gt;data ) {
    int dir = root-&gt;data &lt; data;</p>

<pre><code>root-&gt;link[dir] = jsw_insert_r ( root-&gt;link[dir], data );

if ( is_red ( root-&gt;link[dir] ) ) {
  if ( is_red ( root-&gt;link[!dir] ) ) {
    /* Case 1 Color flip */
    root-&gt;red = 1;
    root-&gt;link[0]-&gt;red = 0;
    root-&gt;link[1]-&gt;red = 0;
  }
  else {
    /* Cases 2 &amp; 3 */
    if ( is_red ( root-&gt;link[dir]-&gt;link[dir] ) )
      root = jsw_single ( root, !dir );
    else if ( is_red ( root-&gt;link[dir]-&gt;link[!dir] ) )
      root = jsw_double ( root, !dir );
  }
}   }
</code></pre>

<p>return root;
}</p>

<p>int jsw_insert ( struct jsw_tree *tree, int data )
{
  tree-&gt;root = jsw_insert_r ( tree-&gt;root, data );
  tree-&gt;root-&gt;red = 0;
  return 1;
}
{% endcodeblock %}</p>

<h3 id="implementation-in-lisp">Implementation in Lisp</h3>

<p>Julienne’s bottom-up algorithm can be easily to be re-written in purely
functional style. The ugly part is the color flipping and assign new branches to
nodes.</p>

<p>Though we can do the color flipping as</p>

<p>{% codeblock lang:cl %}
(setf (rb-red (cadr root)) nil
      (rb-red (cadr a)) T
      (rb-red (cadr b)) T)
{% endcodeblock lang:cl %}</p>

<p>but the tree would be non-persistent. So we need to create new node with new
property of red or black.</p>

<p>I also separate the cases into two function <code>color-flip</code> and
<code>rb-insert-case-rest</code>. Thus the code would be easier to debug and profile.</p>

<p>{% codeblock lang:cl %}
(defun rotate-s (node dir)
  (mtree-let dir node ((a y b) x c)
            ((x-r (to-r x)) (y-b (to-b y)))
            (mtree-expand dir (a y-b (b x-r c)))))</p>

<p>(defun rotate-d (node dir)
  (mtree-let dir node (a x b)
            ((a-new (rotate-s a (not dir))))
            (rotate-s (mtree-expand dir (a-new x b)) dir)))</p>

<p>;; Color flipping utilities 
(defun to-r (x) (make-rb :data (rb-data x) :red T))
(defun to-b (x) (make-rb :data (rb-data x) :red nil))</p>

<p>(defun color-flip (root dir)
  (mtree-let dir root ((a y b) x (c z d))
             ((x-r (to-r x))
              (y-b (to-b y))
              (z-b (to-b z)))
             (mtree-expand dir ((a y-b b) x-r (c z-b d)))))</p>

<p>(defun rb-insert-case-rest (root dir)
  (cond ((is-red (kid root dir dir)) (rotate-s root (not dir)))
        ((is-red (kid root dir (not dir))) (rotate-d root (not dir)))
        (T root)))</p>

<p>(defun rb-insert-r (root data)
  (declare (type fixnum data))
  (cond ((null root) `(nil ,(make-rb :data data) nil))
        ((= data (node-data root)) root)
        (T (let ((dir (&gt; data (node-data root))))
             (mtree-let dir root (a x b) 
               ((b (rb-insert-r b data))
                (root (mtree-expand dir (a x b))))
               (if (is-red b)
                 (if (is-red a)
                   (color-flip root dir)            ; case 1
                   (rb-insert-case-rest root dir))  ; case 2 and 3
                 root))))))</p>

<p>(defparameter <em>tree</em> nil)
(defun rb-insert (data)
  (declare (type fixnum data))
  (let* ((ret (rb-insert-r <em>tree</em> data))
         (a (car ret))            ;; Set the root node to be black
         (x-b (to-b (cadr ret)))
         (b (caddr ret)))
    (setf <em>tree</em> (list a x-b b))
    <em>tree</em>))
{% endcodeblock %}</p>

<p>When the cases in function are separated, it is easy to tell how the program is being called:</p>

<p>{% codeblock lang:cl %}
CL-USER&gt; (trace rb-insert-r rb-insert-case-rest color-flip rotate-s rotate-d)</p>

<p>CL-USER&gt; (rb-insert 3)
  0: (RB-INSERT-R ((NIL 5-b NIL) 6-b (NIL 7-b (NIL 8-r NIL))) 3)
    1: (RB-INSERT-CASE-REST ((NIL 3-r NIL) 5-b NIL) NIL)
    1: RB-INSERT-CASE-REST returned ((NIL 3-r NIL) 5-b NIL)
  0: RB-INSERT-R returned (((NIL 3-r NIL) 5-b NIL) 6-b (NIL 7-b (NIL 8-r NIL)))</p>

<p>CL-USER&gt; (rb-insert 100)
  0: (RB-INSERT-R (((NIL 3-r NIL) 5-b NIL) 6-b (NIL 7-b (NIL 8-r NIL))) 100)
    1: (RB-INSERT-CASE-REST (NIL 8-r (NIL 100-r NIL)) T)
    1: RB-INSERT-CASE-REST returned (NIL 8-r (NIL 100-r NIL))
    1: (RB-INSERT-CASE-REST (NIL 7-b (NIL 8-r (NIL 100-r NIL))) T)
      2: (ROTATE-S (NIL 7-b (NIL 8-r (NIL 100-r NIL))) NIL)
      2: ROTATE-S returned ((NIL 7-r NIL) 8-b (NIL 100-r NIL))
    1: RB-INSERT-CASE-REST returned ((NIL 7-r NIL) 8-b (NIL 100-r NIL))
  0: RB-INSERT-R returned
       (((NIL 3-r NIL) 5-b NIL) 6-b ((NIL 7-r NIL) 8-b (NIL 100-r NIL)))
{% endcodeblock %}</p>

<hr />

<p>I modified the definition of <code>rb</code> structure to make it print prettier:</p>

<p>{% codeblock lang:cl %}
(defstruct 
  (rb (:print-function 
        (lambda (p s k) 
          (declare (ignore k)(type stream s))
          (format s “~d-~:[b~;r~]” (rb-data p) (rb-red p)))))
  (red T :read-only T)
  (data 0 :type fixnum :read-only T))
{% endcodeblock %}</p>

<p>So that when <code>Lisp</code> want to print a <code>rb</code> with data is <code>8</code> and red is <code>nil</code>, it
would print <code>8-b</code> instead of <code>#S(RB :data 8 :red nil)</code>.</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[persistent red black tree in lisp (2)]]></title>
    <link href="http://www.idryman.org/blog/2012/03/31/persistent-red-black-tree-in-lisp-2/"/>
    <updated>2012-03-31T09:22:00+08:00</updated>
    <id>http://www.idryman.org/blog/2012/03/31/persistent-red-black-tree-in-lisp-2</id>
    <content type="html"><![CDATA[<h3 id="single-rotate">Single rotate</h3>

<p>Using the <code>kid</code> utility, we can make rotate single to be simpler too:
{% codeblock lang:cl %}
;;       x              y
;;     /   \          /   \
;;    y     c   =&gt;   a     x     <br />
;;  /   \                 / \
;; a     b               b   c
;;
(defun rotate-s (root dir)
  (let ((x (cadr root))
        (y (cadr (kid (not dir))))
        (a (kid (not dir) (not dir)))
        (b (kid (not dir) dir))
        (c (kid dir)))
    (if dir
        (list a y (list b x c))
        (list (list c x b) y a))))
{% endcodeblock %}</p>

<p>Observe that the two return form is nested reversed. Why not write a macro that
generate this form? Then we only need to write the right case!</p>

<!-- more -->

<h3 id="reverse-the-tree">Reverse the tree</h3>

<p>First we need to write a function that take a nested form and return it in
reversed order (also nested.) To achieve this, we use double recursion.</p>

<p>{% codeblock lang:cl %}
(defun tree-to-rev (tree acc)
   (cond ((null tree) acc)
         ((consp (car tree))
          (tree-to-rev (cdr tree)
               (cons (tree-to-rev (car tree) nil) acc)))
         (T (tree-to-rev (cdr tree) (cons (car tree) acc)))))</p>

<p>CL-USER&gt; (tree-to-rev ‘(a b (c d e)) nil)
((E D C) B A)
{% endcodeblock %}</p>

<p>Recall that we need to add <code>list</code> at the beginning of returned form. So rewrite
the function as</p>

<p>{% codeblock lang:cl %}
(defun tree-to-rev-list (tree acc)
   (cond ((null tree) (cons ‘list acc))
         ((consp (car tree))
          (tree-to-rev-list (cdr tree)
               (cons (tree-to-rev-list (car tree) nil) acc)))
         (T (tree-to-rev-list (cdr tree) (cons (car tree) acc)))))</p>

<p>(defun tree-to-list (tree acc)
   (cond ((null tree) (cons ‘list (reverse acc)))
         ((consp (car tree))
          (tree-to-list (cdr tree)
               (cons (tree-to-list (car tree) nil) acc)))
         (T (tree-to-list (cdr tree) (cons (car tree) acc)))))</p>

<p>CL-USER&gt; (tree-to-rev-list ‘(a b (c d e)) nil)
(LIST (LIST E D C) B A)</p>

<p>CL-USER&gt; (tree-to-list ‘(a b (c d e)) nil)
(LIST A B (LIST C D E))
{% endcodeblock %}</p>

<h3 id="macro-that-simplify-the-return-form">Macro that simplify the return form</h3>

<p>Now we write a macro that we only need to pass it the right case:</p>

<p>{% codeblock lang:cl %}
(defmacro mtree-expand (dir tree)
  `(if ,dir
      ,(tree-to-list tree nil)
      ,(tree-to-rev-list tree nil)))</p>

<p>CL-USER&gt; (macroexpand-1 ‘(mtree-expand dir (a y (b x c))))
(IF DIR
    (LIST A Y (LIST B X C))
    (LIST (LIST C X B) Y A))
{% endcodeblock %}</p>

<p>Now the <code>insert-binary-r</code> and <code>rotate-s</code> can be re-written only in right form!</p>

<p>{% codeblock lang:cl %}
;;       x              y
;;     /   \          /   \
;;    y     c   =&gt;   a     x     <br />
;;  /   \                 / \
;; a     b               b   c
;;
(defun rotate-s (root dir)
  (let ((x (cadr root))
        (y (cadr (kid (not dir))))
        (a (kid (not dir) (not dir)))
        (b (kid (not dir) dir))
        (c (kid dir)))
    (mtree-expand dir (a y (b x c)))))</p>

<p>(defun insert-binary-r (root data)
  (cond ((null root) `(nil ,(make-rb :data data) nil))
        ((= data (node-data root)) root)
        (T (let* ((dir (&gt; data (node-data root)))
                  (x (cadr root))
                  (a (kid root (not dir)))
                  (b (binary-insert-r (kid root dir) data)))
             (mtree-expand dir (a x b))))))
{% endcodeblock %}</p>

<h3 id="macro-that-simplify-the-input-form">Macro that simplify the input form</h3>

<p>We also want to simplify that ugly <code>let</code> form, so we create this function and
macro:</p>

<p>{% codeblock lang:cl %}
(defun gen-let (dir node form dirs)
  (if (atom form)
    <code>((,form (apply #'kid ,node ,(cons 'list (reverse dirs)))))
    (cons </code>(,(cadr form) 
            (cadr (apply #’kid ,node ,(cons ‘list (reverse dirs)))))
          (append (gen-let dir node (car form) (cons `(not ,dir) dirs))
                  (gen-let dir node (caddr form) (cons dir dirs))))))</p>

<p>(defmacro mtree-let (dir node form let-var &amp;body body)
   `(let ,(gen-let dir node form nil)
       (let* ,let-var
           ,@body)))
{% endcodeblock %}</p>

<p>And then you can rewrite <code>rotate-s</code>:</p>

<p>{% codeblock lang:cl %}
(defun rotate-s (node dir)
  (mtree-let dir node ((a y b) x c)
    nil
    (mtree-expand (a y (b x c)))))
{% endcodeblock %}</p>

<p>See? We don’t need to write the comment to remind us the relative position of
variables. The code express itself! You can see what this code will expand
to by expanding the macro:</p>

<p>{% codeblock lang:cl %}
CL-USER&gt; (macroexpand-1 ‘(mtree-let dir node ((a y b) x c)
                          nil
                          (mtree-expand dir (a y (b x c)))))
(LET ((X (CADR (APPLY #’KID NODE (LIST))))
      (Y (CADR (APPLY #’KID NODE (LIST (NOT DIR)))))
      (A (APPLY #’KID NODE (LIST (NOT DIR) (NOT DIR))))
      (B (APPLY #’KID NODE (LIST (NOT DIR) DIR)))
      (C (APPLY #’KID NODE (LIST DIR))))
  (LET* ()
    (MTREE-EXPAND DIR (A Y (B X C)))))
{% endcodeblock %}</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[persistent red black tree in lisp (1)]]></title>
    <link href="http://www.idryman.org/blog/2012/03/30/persistent-red-black-tree-in-lisp-1/"/>
    <updated>2012-03-30T13:57:00+08:00</updated>
    <id>http://www.idryman.org/blog/2012/03/30/persistent-red-black-tree-in-lisp-1</id>
    <content type="html"><![CDATA[<p>I’m a newbie to Lisp programing language. Lisp is one of the most oldest
programming language that is still being used today. People have a lot of
defences on programming languages, because there are too many choices to us
today. Every language has their strength and weakness. It is not easy to make
the choice.</p>

<p>In my opinion, the best way to decide what languages I must learn is to
see which kinds of people are loving it. 
For example, Ruby community does great supports for business plans; Python is
the best open sourced language for academia uses (scientific libraries, machine
learning, computer vision, statistics, visualizations…etc.) Many old school
hackers (including me) still love to use Perl; Java is widely used in big
companies; VBA is friendly for dealing excel data…etc. And <strong>Lisp</strong>, are
highly recommended by great hackers. </p>

<!-- more -->

<hr />

<p>If you are also interested in Lisp, I recommend <a href="http://www.gigamonkeys.com/book/">Practical Common
Lisp</a> written by <a href="http://www.gigamonkeys.com/">Peter Seibel</a>, and <a href="http://paulgraham.com/onlisp.html">On Lisp</a> written
by <a href="http://paulgraham.com/">Paul Graham</a>. Both of them are free, downloadable PDF files, and
there are also online version and epub format.</p>

<hr />

<h3 id="basic-thoughts">Basic thoughts</h3>

<p>Let’s begin with basic structures. At first, I design the structure similar to
what you will write in C code.</p>

<p>{% codeblock lang:cl %}
(defstruct rb
  left
  right
  red
  data)
{% endcodeblock %}</p>

<p>Here we can see the power of Lisp. It does not only create the structure, but
also create constructor and accessors for the structure. Now you can create the
<code>rb</code> and access it like so:</p>

<p>{% codeblock lang:cl %}
(setq node
  (make-rb :left nil :right nil :red T :data 3))</p>

<p>==&gt; #S(RB :left nil :right nil :red T :data 3)</p>

<p>(rb-left node)</p>

<p>==&gt; nil</p>

<p>(rb-data node)</p>

<p>==&gt; 3</p>

<p>(setf (rb-right node) (make-rb :data 5)) ; Other field are default as nil</p>

<p>==&gt; #S(RB :left nil 
          :right #S(RB :left nil :right nil :red nil :data 5) 
          :red T :data 3)
{% endcodeblock %}</p>

<p>This seems to be nice. But we can rewrite it in more lispy style:</p>

<p>{% codeblock lang:cl %}
(defstruct rb
  (red T) ; default value for red
  data)</p>

<p>;; A node can be represented as
;; (nil #S(RB :red T :data 3) nil)
;; To generate this:
(list nil (make-rb :data 3) nil)</p>

<p>==&gt; (nil #S(RB :red T :data 3) nil)</p>

<p>;; You can also use lisp syntax candy
`(list nil ,(make-rb :data 3) nil)</p>

<p>==&gt; (nil #S(RB :red T :data 3) nil)
{% endcodeblock %}</p>

<p>The s-expression with a preceding <code>`</code> means that it is a expression that
lisp don’t evaluate, except expression inside it with a preceding <code>,</code>. It is
convenient for us to generate new list object.</p>

<p>To access the elements in a list:</p>

<ol>
  <li><code>car</code> the first</li>
  <li><code>cadr</code> the second</li>
  <li><code>caddr</code> the third</li>
</ol>

<p>And now we can wirte a persistant basic binary insert function!</p>

<p>{% codeblock lang:cl %}
(defun binary-insert-r (root data)
  (cond ((null root)                            ; cond works like “switch”
          `(nil ,(make-rb :data data) nil))     ; make node when reach leaf
        ((= data (rb-data (cadr root))) root)   ; return self if data is the same
        ((&gt; data (rb-data (cadr root)))
         (list (car root)                     <br />
               (cadr root) 
               (binary-insert-r (caddr root) data))) ; case insert to right
        (T
         (list (binary-insert-r (car root) data) 
               (cadr root)
               (caddr root)))))                      ; case insert to left</p>

<p>(defparameter <em>tree</em> nil)                     ; global variable <em>tree</em>
(defun binary-insert (data)
  (setf <em>tree</em> (binary-insert-r <em>tree</em> data)) ; set <em>tree</em> as the returned tree
  <em>tree</em>)                                     ; return <em>tree</em> value</p>

<p>{% endcodeblock %}</p>

<p>Let’s exam the function:
{% codeblock lang:cl %}
BINARY-INSERT-R
CL-USER&gt; (binary-insert 6)
(NIL #S(RB :RED T :DATA 6) NIL)
CL-USER&gt; (binary-insert 7)
(NIL #S(RB :RED T :DATA 6) (NIL #S(RB :RED T :DATA 7) NIL))
CL-USER&gt; (binary-insert 5)
((NIL #S(RB :RED T :DATA 5) NIL) #S(RB :RED T :DATA 6)
 (NIL #S(RB :RED T :DATA 7) NIL))
CL-USER&gt; (binary-insert 8)
((NIL #S(RB :RED T :DATA 5) NIL) #S(RB :RED T :DATA 6)
  (NIL #S(RB :RED T :DATA 7) (NIL #S(RB :RED T :DATA 8) NIL)))
{% endcodeblock %}</p>

<h3 id="wait-hold-on">Wait! Hold on!</h3>

<p>The code is god damn ugly! We can fix it with some utilities:</p>

<p>{% codeblock lang:cl %}
(defun kid (root &amp;rest dirs)
  (cond ((consp dirs)
         (if (car dirs)
             (apply #’kid (caddr root) (cdr dirs))
             (apply #’kid (car root) (cdr dirs))))
        (T root)))</p>

<p>(defun node-data (root)
  (rb-data (cadr root)))
{% endcodeblock %}</p>

<p>The <code>kid</code> takes a node and a series of <code>T</code> and <code>nil</code>; When it saw a <code>T</code>, it
returns the right node, or it will return the left one. For example:</p>

<p>{% codeblock lang:cl %}
CL-USER&gt; (kid <em>tree</em> nil)            ; left node
(NIL #S(RB :RED T :DATA 5) NIL) 
CL-USER&gt; (kid <em>tree</em> T)              ; right node
(NIL #S(RB :RED T :DATA 7) (NIL #S(RB :RED T :DATA 8) NIL))
CL-USER&gt; (kid <em>tree</em> T T)            ; right right node
(NIL #S(RB :RED T :DATA 8) NIL)
{% endcodeblock %}</p>

<p>Using <code>nil</code> and <code>T</code> as left and right dirctions, it is easier for us to rewrite
<code>binary-insert-r</code> because we can change left and right cases into variables.</p>

<p>{% codeblock lang:cl %}
(defun binary-insert-r (root data)
  (cond ((null root) `(nil ,(make-rb :data data) nil))
        ((= data (node-data root)) root)
        (T (let* ((dir (&gt; data (node-data root)))
                  (a (kid root (not dir)))
                  (b (binary-insert-r (kid root dir) data)))
             (if dir
                 (list a (cadr root) b)
                 (list b (cadr root) a))))))
{% endcodeblock %}</p>

]]></content>
  </entry>
  
</feed>
