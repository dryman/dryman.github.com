<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Algorithm | Carpe diem (Felix's blog)]]></title>
  <link href="http://www.idryman.org/blog/categories/algorithm/atom.xml" rel="self"/>
  <link href="http://www.idryman.org/"/>
  <updated>2017-07-05T09:13:52-07:00</updated>
  <id>http://www.idryman.org/</id>
  <author>
    <name><![CDATA[dryman (Felix Ren-Chyan Chern)]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Writing a damn fast hash table with tiny memory footprints]]></title>
    <link href="http://www.idryman.org/blog/2017/05/03/writing-a-damn-fast-hash-table-with-tiny-memory-footprints/"/>
    <updated>2017-05-03T18:26:00-07:00</updated>
    <id>http://www.idryman.org/blog/2017/05/03/writing-a-damn-fast-hash-table-with-tiny-memory-footprints</id>
    <content type="html"><![CDATA[<p>Hash table is probably <em>the</em> most commonly used data structure in
software industry. Most implementations focus on its speed instead
of memory usage, yet small memory footprint has significant impact
on large in-memory tables and database hash indexes.</p>

<p>In this post, I”ll provide a step by step guide for writing a modern
hash table that optimize for both speed and memory efficiency. I’ll
also give some mathematical bounds on how well the hash table could
achieve, and shows how close we are to the optimal.</p>

<!--more-->

<hr />

<p>Let me start with a disclaimer. I now work at google, and this project
(OPIC including the hash table implementation) is approved by google
<a href="https://opensource.google.com/docs/iarc/">Invention Assignment Review Committee</a> as my personal
project. The work is done only in my spare time with my own machine
and does not use and/or reference any of the google internal resources.</p>

<h2 id="common-hash-table-memory-usages">Common hash table memory usages</h2>

<p>As mentioned earlier, most hash hash table focus on its speed, not
memory usage. Consequently there’s not much benchmark compares the
memory these hash table implementation consumes. Here is a very basic
table for some high performance hash table I found. The input is 8 M
key-value pairs; size of each key is 6 bytes and size of each value is
8 bytes. The lower bound memory usage is $(6+8)\cdot 2^{23} =$ 117MB
. Memory overhead is computed as memory usage divided by the
theoretical lower bound. Currently I only collect 5 hash table
implementations. More to be added in future.</p>

<table>
  <thead>
    <tr>
      <th> </th>
      <th style="text-align: right">Memory Usage</th>
      <th style="text-align: right">　Memory Overhead</th>
      <th style="text-align: right">　Insertion Time</th>
      <th style="text-align: right">　Query Time</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>std::unordered_map</td>
      <td style="text-align: right">588M</td>
      <td style="text-align: right">5.03x</td>
      <td style="text-align: right">2.626 sec</td>
      <td style="text-align: right">2.134 sec</td>
    </tr>
    <tr>
      <td>sparse_hash_map</td>
      <td style="text-align: right">494M</td>
      <td style="text-align: right">4.22x</td>
      <td style="text-align: right">7.393 sec</td>
      <td style="text-align: right">2.112 sec</td>
    </tr>
    <tr>
      <td>dense_hash_map</td>
      <td style="text-align: right">1280M</td>
      <td style="text-align: right">10.94x</td>
      <td style="text-align: right">1.455 sec</td>
      <td style="text-align: right">1.436 sec</td>
    </tr>
    <tr>
      <td>libcuckoo</td>
      <td style="text-align: right">708M</td>
      <td style="text-align: right">6.05x</td>
      <td style="text-align: right">2.026 sec</td>
      <td style="text-align: right">2.120 sec</td>
    </tr>
    <tr>
      <td>klib khash</td>
      <td style="text-align: right">642M</td>
      <td style="text-align: right">5.48x</td>
      <td style="text-align: right">4.232 sec</td>
      <td style="text-align: right">1.647 sec</td>
    </tr>
  </tbody>
</table>

<hr />

<p>The metrics above actually surprises me. For example,
[sparse hash map][shm] is advertised to use 4-10 bits per entry,
but the overhead is actually 4 times the lower bound. If the
hash table were implemented as large key-value store index, and
you have 1 TB of data, you’ll need at least 4-5TB of space to
hold the data. That’s not very space efficient. Can we do better?</p>

<h2 id="overview-of-hash-table-types">Overview of hash table types</h2>

<p>There’s two major types of hash table, one is <a href="https://en.wikipedia.org/wiki/Hash_table#Separate_chaining">chaining</a> and
the other is <a href="https://en.wikipedia.org/wiki/Open_addressing">open addressing</a>. Chaining is quite common
in most standard libraries, where the collision is handled by
appending items into a linked list headed by the bucket the key is
mapped to.  Open addressing uses a different mechanism to handle
collision: the key (and value) is inserted to another bucket if the
bucket it attempt to insert is already occupied.</p>

<p>Open addressing has some clear advantages over chaining. First, it
does not require extra memory allocation. This reduces memory allocation
overhead and can possibly improve cpu caching. Moreover, in open
addressing the developer has more control on memory layout – placing
elements in buckets with certain order to make probing (search on
alternative location for key) fast. Best of all, open addressing
gives us better memory lower bound over chaining.</p>

<p>The hash collision rate affects the chaining memory usage.  Given a
hash table with $N$ buckets, we insert $M$ elements into the
table. The expected collision number in the table is $M(1 - (1 -
1/N)^{M-1})$. For a table with 1000 buckets the expected collisions
under high loads ($M/N &gt; 80%$) are:</p>

<ul>
  <li>80% -&gt; 440</li>
  <li>90% -&gt; 534</li>
  <li>100% -&gt; 632</li>
</ul>

<p><img src="/images/collision_rate.png" alt="collision" /></p>

<p>Accounting the extra payload that chaining requires, we can now compute
the lower bound for the overhead under different loads.</p>

<table>
  <thead>
    <tr>
      <th style="text-align: right">load</th>
      <th style="text-align: right">　Chaining</th>
      <th style="text-align: right">　Open Addressing</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: right">100%</td>
      <td style="text-align: right">1.31x</td>
      <td style="text-align: right">1.00x</td>
    </tr>
    <tr>
      <td style="text-align: right">90%</td>
      <td style="text-align: right">1.37x</td>
      <td style="text-align: right">1.11x</td>
    </tr>
    <tr>
      <td style="text-align: right">80%</td>
      <td style="text-align: right">1.47x</td>
      <td style="text-align: right">1.25x</td>
    </tr>
    <tr>
      <td style="text-align: right">70%</td>
      <td style="text-align: right">1.60x</td>
      <td style="text-align: right">1.42x</td>
    </tr>
    <tr>
      <td style="text-align: right">50%</td>
      <td style="text-align: right">2.09x</td>
      <td style="text-align: right">2.00x</td>
    </tr>
    <tr>
      <td style="text-align: right">25%</td>
      <td style="text-align: right">4.03x</td>
      <td style="text-align: right">4.00x</td>
    </tr>
  </tbody>
</table>

<p>Here I assume if the collision rate were 60%, half of it is chained
and half of it fits the buckets. The actual number may have some
digits off, but it doesn’t change my conclusion on choosing open
addressing for hash table implementation.</p>

<h2 id="probing-methods">Probing methods</h2>

<p>In open addressing, hash collisions are resolved by probing, a search
through alternative buckets until the target record is found, or some
failure criteria is met. The following all belongs to some kinds of
probing strategies:</p>

<ul>
  <li>Linear Probing</li>
  <li>Quadratic Probing</li>
  <li>Double Hashing</li>
  <li>Hopscotch Hashing</li>
  <li>Robin Hood Hashing</li>
  <li>Cuckoo Hashing</li>
</ul>

<p>For each of the probing method, we’re interested in their worst case
and average case probing numbers, and is their space bound. </p>

<h3 id="linear-probing-and-quadratic-probing">Linear Probing and Quadratic Probing</h3>

<p>Linear probing can be represented as a hash function of a key and a
probe number $h(k, i) = (h(k) + i) \mod N$. Similarly, quadratic
probing is usually written as $h(k, i) = (h(k) + i^2) \mod N$. Both
methods has worst case probing count $O(N)$, and are bounded on
space usage. In other words, there no condition where we need to
increase the bucket count and rehash.</p>

<h3 id="double-hashing">Double hashing</h3>

<p>Double hashing can be written as
$h(k, i) = (h1(k) + i \cdot h2(k)) \mod N$.
Same as linear probing and quadratic probing, it has worst
case probing count $O(N)$, and is bounded on space usage.</p>

<h3 id="hopscotch-hashing">Hopscotch Hashing</h3>

<p>Here is the algorithm copied from <a href="https://en.wikipedia.org/wiki/Hopscotch_hashing">wikipedia</a>.
This is how the collision is handled</p>

<blockquote>
  <p>If the empty entry’s index j is within H-1 of entry i, place x
 there and return. Otherwise, find an item y whose hash value lies
 between i and j, but within H-1 of j. Displacing y to j creates a
 new empty slot closer to i. If no such item y exists, or if the
 bucket i already contains H items, resize and rehash the table.</p>
</blockquote>

<p>This mechanism has a good worst case probing number $O(H)$. However,
since it could resize the hash table, the hash table size is unbounded.</p>

<h3 id="robin-hood-hashing">Robin Hood Hashing</h3>

<p>The concept for robin hood hashing is simple and clever. When
a collision occur, compare the two items’ probing count, the one
with larger probing number stays and the other continue to probe.
Repeat until the probing item finds an empty spot. For more detailed
analysis checkout <a href="https://cs.uwaterloo.ca/research/tr/1986/CS-86-14.pdf">the original paper</a>. It’s worth to read.</p>

<p>The expected probing length is</p>

<script type="math/tex; mode=display">% &lt;![CDATA[

\begin{align}
E\lbrack i \rbrack & = \frac{n}{m}\left(\sum_{x=1}^n\frac{1}{x} -
\sum_{x=1}^{n-m}\frac{1}{x}\right) \\
& = \frac{n}{m}\left(H_n - H_{n-m} \right) \\
& \approx \frac{n}{m}\ln\left(\frac{1}{1-\frac{m}{n}}\right)
\end{align}
 %]]&gt;</script>

<p><img src="/images/psl.png" alt="psl" /></p>

<p>Even under a high load, we still get very good probing numbers.
The best thing about robin hood hashing is it does not expand
the hash table, which is important because we want to build a
hash table with bounded size. This is the probing strategy I chose.</p>

<h3 id="cuckoo-hashing">Cuckoo hashing</h3>

<p>The following description is also copied from <a href="https://en.wikipedia.org/wiki/Cuckoo_hashing">wikipedia</a>.</p>

<blockquote>
  <p>It uses two or more hash functions, which means any key/value pair
could be in two or more locations. For lookup, the first hash
function is used; if the key/value is not found, then the second hash
function is used, and so on. If a collision happens during insertion,
then the key is re-hashed with the second hash function to map it to
another bucket.</p>
</blockquote>

<p>The expected probing number is below 2. However, the load factor has
to be below 50% to achieve good performance. For using 3 hash functions,
the load can increase to 91%. Combining linear/quadratic probing with
cuckoo, the load factor can go beyond 80%. (All numbers comes from
wikipedia).</p>

<h2 id="optimizing-division-for-hash-table-size">Optimizing Division for Hash Table Size</h2>

<p>I implemented a robin hood hashing prototype a month ago. The prototype
satisfy the low memory footprint, but hard to get it fast. The major
reason is the modulo operation is very slow on most platforms. For example,
on Intel Haswell the <code>div</code> instruction on 64bit integer can take 32-96
cycles. Almost all major hash implementation use power of 2 table size,
so that the modulo is just one bitwise and operation. The problem with
power of 2 table size is it scales too fast! If our data size is 1 bit
above 2GB, the table must be at least 4GB, giving us 50% load. Finding
a fast alternative modulo operation is critical for creating a table
with high load without loosing much performance.</p>

<p>Professor Lemire is probably the first person that addresses this issue.
He wrote a blog post that provides <a href="http://lemire.me/blog/2016/06/27/a-fast-alternative-to-the-modulo-reduction/">a fast alternative to modulo</a>.</p>

<p><code>c
uint32_t reduce(uint32_t x, uint32_t N) {
  return ((uint64_t) x * (uint64_t) N) &gt;&gt; 32 ;
}
</code></p>

<p>He named this method as <em>fast range</em>. Another intuitive way to think
about it is <strong>scaling</strong>. Number $x$ ranges $\lbrack 0, 2^{32}-1\rbrack$,
multiplying it by $N$ then divide by $2^{32}$, the range becomes
$\lbrack 0, N-1\rbrack$.</p>

<p>There’s one big problem to apply <em>fast range</em> on probing. Probing
usually add the probe bias to <em>lower bits</em> of the hashed key. Modulo
and bitwise and preserves the lower bits information, but <em>fast range</em>
only use the <em>higher bits</em> and the probe would have no effect on the
output. The first bits where it can bias the output in <em>fast range</em> is
$\frac{2^{32}}{N}$. Hence, writing a linear probing using <em>fast range</em>
would be:</p>

<p><code>c
uint32_t fast_range_probing(uint32_t hashed_key, uint32_t probe, uint32_t N)
{
  return ((uint64_t)hashe_key + ((uint64_t)probe &lt;&lt; 32)/N) * N &gt;&gt; 32;
}
</code></p>

<p>To make the output correct we used division again, which makes it slow.
Is there a better way?</p>

<h3 id="fast-mod-and-scale">Fast mod and scale</h3>

<p>I created an alternative method with a more relaxed condition.
Instead of finding a fast modulo replacement for <strong>all N</strong>, I want to
find <strong>some N</strong> that satisfy fast modulo and can preserve the biases
of probing.</p>

<p>The actual algorithm is pretty simple: First, mask the hashed key to
the next power of 2 boundary, then multiply it by
$\frac{N}{16}, N=8..15$. This is a combination of traditional power
of 2 modulo and professor Lemire’s scaling method. The difference is
now the scale can only get up to 2 times. In other words, only the least
significant bit will get omitted when scaling. The probing
implementation can be written as:</p>

<p>```c
static inline uintptr_t
hash_with_probe(RobinHoodHash* rhh, uint64_t key, int probe)
{
  uintptr_t mask = (1ULL « (64 - rhh-&gt;capacity_clz)) - 1;</p>

<p>// linear probing
  // uint64_t probed_hash = key + probe * 2;</p>

<p>// quadratic probing
  uint64_t probed_hash = key + probe * probe * 2;</p>

<p>// Fast mod and scale
  return (probed_hash &amp; mask) * rhh-&gt;capacity_ms4b » 4;
}
```</p>

<p>This is <a href="https://github.com/dryman/opic/blob/master/opic/hash/robin_hood.c#L155">the straight copy</a> of my robin hood hash
implementation.  When the probe is scaled by 2 it is guaranteed to
have biases on the output. The mask can be derived from leading zeros
of the capacity <code>capacity_clz</code>, the scale is defined by the most
significant 4 bits of the capacity <code>capacity_ms4b</code>. The <code>capacity_ms4b</code>
is pre-computed on hash table creation or resizing time. It’s a round
up of desired capacity with finer granularity compare to power of 2
tables.</p>

<p>I used <a href="https://software.intel.com/en-us/articles/intel-architecture-code-analyzer">Intel Architecture Code Analyzer</a> to analyze the instruction
throughput of my methods, and the result is very satisfying:</p>

<ul>
  <li>Power of 2 table with quadratic probing
    <ul>
      <li>Block Throughput: 4.10 Cycles</li>
      <li>Total Num Of Uops: 9</li>
    </ul>
  </li>
  <li>Fast mod and scale with quadratic probing
    <ul>
      <li>Block Throughput: 4.15 Cycles</li>
      <li>Total Num Of Uops: 12</li>
    </ul>
  </li>
</ul>

<h2 id="benchmarks">Benchmarks</h2>

<p>I hope all these analysis didn’t bored you all! Turns out these analysis
are all useful. We now have a hash table with very optimal memory usage
but still having great performance.</p>

<p><img src="/images/short_key_mem.png" alt="Memory usage" /></p>

<p><img src="/images/short_key_insert_time.png" alt="Insert time" /></p>

<p><img src="/images/short_key_lookup_time.png" alt="Lookup time" /></p>

<p>The most impressive part is the memory usage. Under load 89% we
achieve overhead 1.20x ~ 1.50x. The ideal overhead should be 1.12 but
we have an extra byte used per bucket to determine whether the bucket
is emptied or tumbstoned.</p>

<p>The insertion time is not as good as <code>dense_hash_map</code> under high load.
The reason is robin hood hashing moves the buckets around during the
insert, but <code>dense_hash_map</code> simply probe and insert it to an empty
bucket if found.</p>

<p>Luckily, robin hood hashing gets a faster lookup time compare to
<code>dense_hash_map</code>. I think the major reason is robin hood hashing
results a great expected probing number, and the overall throughput
benefits from it.</p>

<p>The benchmark code is available at <a href="https://github.com/dryman/hash_bench">hash_bench</a>. My robin hood
hashing implementation is available at <a href="http://opic.rocks/struct_robin_hood_hash%E3%80%80.html">opic robin hood hashing</a>.</p>

<h2 id="summary">Summary</h2>

<p>Hash table implementations has been focused on its speed over memory
usages. Turns out we can sacrifice some insertion time to gain way
better memory utilization, and also improve the look up time. I believe
this can be the new state of the art implementation for hash tables.
Let me know what you think in the comments. :)</p>

<p>Many details were omitted in this post, but will be discussed on my
next post. Some outlines for the things I’d like to cover would be</p>

<ul>
  <li>Probe distributions under different probing strategies (linear probing, quadratic probing, double hashing, and some probing methods I created).</li>
  <li>Optimize probing by using gcc/clang vector extensions</li>
  <li>Deletion mechanisms, its performance, and how it affects probe distributions.</li>
  <li>Serialization and deserialization performance</li>
  <li>Performance with different popular hash functions</li>
  <li>Benchmark with other robin hood implementations</li>
  <li>Benchmark with other embedded key-value store.</li>
</ul>

<p>I may not be able to cover all the above in my next post, so please
put down your comment and let me know what do you want to read the most.</p>

<h2 id="one-more-thing">One more thing…</h2>

<p>This robin hood hashing is implemented using my project
<a href="https://github.com/dryman/opic">Object Persistence In C (OPIC)</a>. OPIC is a new general serialization
framework I just released. Any in-memory object created with OPIC can
be serialized without knowing how it was structured. Deserializing
objects from OPIC only requires one mmap syscall. That’s say, this
robin hood implementation can work not only in a living process, the
data it stored can be used as a key-value store after the process exits.</p>

<p>Right now, the throughput of OPIC robin hood hash map on small keys (6bytes)
is 9M (1048576/0.115454). This is way better than most
<a href="http://www.datastax.com/nosql-databases/benchmarks-cassandra-vs-mongodb-vs-hbase">NoSQL key-value stores</a>. The difference might come from
write ahead logs or some other IO? I’m not sure why the performance
gain is so huge. My next stop is to benchmark against other embedded
key-value store like rocksdb, leveldb and so forth.</p>

<h2 id="references">References</h2>

<p>If you’d like to know more about robin hood hashing, here are some
posts worth to read:</p>

<ul>
  <li>
    <p><a href="https://www.sebastiansylvan.com/post/robin-hood-hashing-should-be-your-default-hash-table-implementation/">Robin Hood Hashing should be your default Hash Table implementation</a></p>
  </li>
  <li>
    <p><a href="http://codecapsule.com/2013/11/17/robin-hood-hashing-backward-shift-deletion/">Robin Hood hashing: backward shift deletion</a></p>
  </li>
  <li>
    <p><a href="https://probablydance.com/2017/02/26/i-wrote-the-fastest-hashtable/">I Wrote The Fastest Hashtable</a></p>
  </li>
  <li>
    <p>[Unfinished draft of linearly probed robin hood hashing][https://pubby8.wordpress.com/2017/05/08/an-unfinished-draft-of-linearly-probed-robin-hood-hash-tables/?iframe=true&amp;theme_preview=true]</p>
  </li>
  <li>
    <p><a href="https://cs.uwaterloo.ca/research/tr/1986/CS-86-14.pdf">Original paper of robin hood hashing</a></p>
  </li>
</ul>

<h2 id="edits">Edits</h2>

<h4 id="section">5/7/17</h4>

<p>As people pointed out in hacker news and comment below, C++
<code>std::string</code> has 24 bytes overhead on small strings, so the memory
comparison is not fair.  I’ll conduct another set of benchmarks using
integers tonight.</p>

<p>Also, one of the author of libcuckoo (@dga) pointed out that libcuckoo
would perform better if I use thread-unsafe version. I’ll also update
the benchmark with this new setup.</p>

<p>The short string problem brings up a question: what is the best
practice to use C++ hash map with short strings? Isn’t this a common
use case in daily programming? I tried to do some quick search but
didn’t find any useful information, and I’m suck at C++…
Any good idea on how to do this better?</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[persistent red black tree in lisp (4)]]></title>
    <link href="http://www.idryman.org/blog/2012/04/01/persistent-red-black-tree-4/"/>
    <updated>2012-04-01T14:48:00-07:00</updated>
    <id>http://www.idryman.org/blog/2012/04/01/persistent-red-black-tree-4</id>
    <content type="html"><![CDATA[<h3 id="okasakis-purely-functional-red-black-tree">Okasaki’s purely functional red black tree</h3>

<p>The peristent red black tree in last post works ok, but the rotate functions and
color flip is not efficient for purely functional data sturctures.
In 1999, Okasaki introduced a new way to balance the insertion, and the function
only takes care of four unbalanced cases.</p>

<pre><code>Chris Okasaki,
"Red-Black Trees in a Functional Setting",
Journal of Functional Programming, 9(4),
pp471-477,
July 1999
</code></pre>

<p>The algorithm is easy to present in Haskell code:</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><figcaption><span>Okasaki’s red black tree insertion</span><a href='http://www.mew.org/~kazu/proj/red-black-tree/'>Copied from Kazu Yamamoto’s website</a></figcaption> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
</pre></td><td class='code'><pre><code class='hs'><span class='line'><span class="kr">data</span> <span class="kt">RBTree</span> <span class="n">a</span> <span class="ow">=</span> <span class="kt">Leaf</span> <span class="o">|</span> <span class="kt">Fork</span> <span class="kt">Color</span> <span class="p">(</span><span class="kt">RBTree</span> <span class="n">a</span><span class="p">)</span> <span class="n">a</span> <span class="p">(</span><span class="kt">RBTree</span> <span class="n">a</span><span class="p">)</span>
</span><span class='line'><span class="kr">data</span> <span class="kt">Color</span> <span class="ow">=</span> <span class="kt">R</span> <span class="o">|</span> <span class="kt">B</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="n">insert</span> <span class="ow">::</span> <span class="kt">Ord</span> <span class="n">a</span> <span class="o">=&amp;</span><span class="n">gt</span><span class="p">;</span> <span class="n">a</span> <span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span> <span class="kt">RBTree</span> <span class="n">a</span> <span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span> <span class="kt">RBTree</span> <span class="n">a</span>
</span><span class='line'><span class="nf">insert</span> <span class="n">a</span> <span class="n">b</span> <span class="ow">=</span> <span class="kt">Fork</span> <span class="kt">B</span> <span class="n">d</span> <span class="n">e</span> <span class="n">f</span>
</span><span class='line'>  <span class="kr">where</span>
</span><span class='line'>    <span class="kt">Fork</span> <span class="kr">_</span> <span class="n">d</span> <span class="n">e</span> <span class="n">f</span> <span class="ow">=</span> <span class="n">ins</span> <span class="n">a</span> <span class="n">b</span>
</span><span class='line'>    <span class="n">ins</span> <span class="n">x</span> <span class="kt">Leaf</span> <span class="ow">=</span> <span class="kt">Fork</span> <span class="kt">R</span> <span class="kt">Leaf</span> <span class="n">x</span> <span class="kt">Leaf</span>
</span><span class='line'>    <span class="n">ins</span> <span class="n">x</span> <span class="n">t</span><span class="o">@</span><span class="p">(</span><span class="kt">Fork</span> <span class="n">c</span> <span class="n">l</span> <span class="n">y</span> <span class="n">r</span><span class="p">)</span> <span class="ow">=</span> <span class="kr">case</span> <span class="n">compare</span> <span class="n">x</span> <span class="n">y</span> <span class="kr">of</span>
</span><span class='line'>        <span class="kt">LT</span> <span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span> <span class="n">balanceL</span> <span class="n">c</span> <span class="p">(</span><span class="n">ins</span> <span class="n">x</span> <span class="n">l</span><span class="p">)</span> <span class="n">y</span> <span class="n">r</span>
</span><span class='line'>        <span class="kt">GT</span> <span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span> <span class="n">balanceR</span> <span class="n">c</span> <span class="n">l</span> <span class="n">y</span> <span class="p">(</span><span class="n">ins</span> <span class="n">x</span> <span class="n">r</span><span class="p">)</span>
</span><span class='line'>        <span class="kt">EQ</span> <span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span> <span class="n">t</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="n">balanceL</span> <span class="ow">::</span> <span class="kt">Color</span> <span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span> <span class="kt">RBTree</span> <span class="n">a</span> <span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span> <span class="n">a</span> <span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span> <span class="kt">RBTree</span> <span class="n">a</span> <span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span> <span class="kt">RBTree</span> <span class="n">a</span>
</span><span class='line'><span class="nf">balanceL</span> <span class="kt">B</span> <span class="p">(</span><span class="kt">Fork</span> <span class="kt">R</span> <span class="p">(</span><span class="kt">Fork</span> <span class="kt">R</span> <span class="n">a</span> <span class="n">x</span> <span class="n">b</span><span class="p">)</span> <span class="n">y</span> <span class="n">c</span><span class="p">)</span> <span class="n">z</span> <span class="n">d</span> <span class="ow">=</span> <span class="kt">Fork</span> <span class="kt">R</span> <span class="p">(</span><span class="kt">Fork</span> <span class="kt">B</span> <span class="n">a</span> <span class="n">x</span> <span class="n">b</span><span class="p">)</span> <span class="n">y</span> <span class="p">(</span><span class="kt">Fork</span> <span class="kt">B</span> <span class="n">c</span> <span class="n">z</span> <span class="n">d</span><span class="p">)</span>
</span><span class='line'><span class="nf">balanceL</span> <span class="kt">B</span> <span class="p">(</span><span class="kt">Fork</span> <span class="kt">R</span> <span class="n">a</span> <span class="n">x</span> <span class="p">(</span><span class="kt">Fork</span> <span class="kt">R</span> <span class="n">b</span> <span class="n">y</span> <span class="n">c</span><span class="p">))</span> <span class="n">z</span> <span class="n">d</span> <span class="ow">=</span> <span class="kt">Fork</span> <span class="kt">R</span> <span class="p">(</span><span class="kt">Fork</span> <span class="kt">B</span> <span class="n">a</span> <span class="n">x</span> <span class="n">b</span><span class="p">)</span> <span class="n">y</span> <span class="p">(</span><span class="kt">Fork</span> <span class="kt">B</span> <span class="n">c</span> <span class="n">z</span> <span class="n">d</span><span class="p">)</span>
</span><span class='line'><span class="nf">balanceL</span> <span class="n">k</span> <span class="n">a</span> <span class="n">x</span> <span class="n">b</span>                           <span class="ow">=</span> <span class="kt">Fork</span> <span class="n">k</span> <span class="n">a</span> <span class="n">x</span> <span class="n">b</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="n">balanceR</span> <span class="ow">::</span> <span class="kt">Color</span> <span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span> <span class="kt">RBTree</span> <span class="n">a</span> <span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span> <span class="n">a</span> <span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span> <span class="kt">RBTree</span> <span class="n">a</span> <span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span> <span class="kt">RBTree</span> <span class="n">a</span>
</span><span class='line'><span class="nf">balanceR</span> <span class="kt">B</span> <span class="n">a</span> <span class="n">x</span> <span class="p">(</span><span class="kt">Fork</span> <span class="kt">R</span> <span class="n">b</span> <span class="n">y</span> <span class="p">(</span><span class="kt">Fork</span> <span class="kt">R</span> <span class="n">c</span> <span class="n">z</span> <span class="n">d</span><span class="p">))</span> <span class="ow">=</span> <span class="kt">Fork</span> <span class="kt">R</span> <span class="p">(</span><span class="kt">Fork</span> <span class="kt">B</span> <span class="n">a</span> <span class="n">x</span> <span class="n">b</span><span class="p">)</span> <span class="n">y</span> <span class="p">(</span><span class="kt">Fork</span> <span class="kt">B</span> <span class="n">c</span> <span class="n">z</span> <span class="n">d</span><span class="p">)</span>
</span><span class='line'><span class="nf">balanceR</span> <span class="kt">B</span> <span class="n">a</span> <span class="n">x</span> <span class="p">(</span><span class="kt">Fork</span> <span class="kt">R</span> <span class="p">(</span><span class="kt">Fork</span> <span class="kt">R</span> <span class="n">b</span> <span class="n">y</span> <span class="n">c</span><span class="p">)</span> <span class="n">z</span> <span class="n">d</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">Fork</span> <span class="kt">R</span> <span class="p">(</span><span class="kt">Fork</span> <span class="kt">B</span> <span class="n">a</span> <span class="n">x</span> <span class="n">b</span><span class="p">)</span> <span class="n">y</span> <span class="p">(</span><span class="kt">Fork</span> <span class="kt">B</span> <span class="n">c</span> <span class="n">z</span> <span class="n">d</span><span class="p">)</span>
</span><span class='line'><span class="nf">balanceR</span> <span class="n">k</span> <span class="n">a</span> <span class="n">x</span> <span class="n">b</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<!-- more -->

<p>Cool! This can be even reduced to only two cases in our <code>mtree-expand</code> and
<code>mtree-let</code> macro!</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
</pre></td><td class='code'><pre><code class='cl'><span class='line'><span class="p">(</span><span class="nb">defun</span> <span class="nv">balance-o</span> <span class="p">(</span><span class="nv">root</span> <span class="nv">dir</span><span class="p">)</span>
</span><span class='line'>  <span class="p">(</span><span class="nv">mtree-let</span> <span class="nv">dir</span> <span class="nv">root</span> <span class="p">(</span><span class="nv">a</span> <span class="nv">x</span> <span class="p">(</span><span class="nv">b</span> <span class="nv">y</span> <span class="p">(</span><span class="nv">c</span> <span class="nv">z</span> <span class="nv">d</span><span class="p">)))</span>
</span><span class='line'>             <span class="p">((</span><span class="nv">z-b</span> <span class="p">(</span><span class="nv">to-b</span> <span class="nv">z</span><span class="p">)))</span>
</span><span class='line'>             <span class="p">(</span><span class="nv">mtree-expand</span> <span class="nv">dir</span> <span class="p">((</span><span class="nv">a</span> <span class="nv">x</span> <span class="nv">b</span><span class="p">)</span> <span class="nv">y</span> <span class="p">(</span><span class="nv">c</span> <span class="nv">z-b</span> <span class="nv">d</span><span class="p">)))))</span><span class="nv">&lt;/p&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="nv">&lt;p&gt;</span><span class="p">(</span><span class="nb">defun</span> <span class="nv">balance-i</span> <span class="p">(</span><span class="nv">root</span> <span class="nv">dir</span><span class="p">)</span>
</span><span class='line'>  <span class="p">(</span><span class="nv">mtree-let</span> <span class="nv">dir</span> <span class="nv">root</span> <span class="p">(</span><span class="nv">a</span> <span class="nv">x</span> <span class="p">((</span><span class="nv">b</span> <span class="nv">z</span> <span class="nv">c</span><span class="p">)</span> <span class="nv">y</span> <span class="nv">d</span><span class="p">))</span>
</span><span class='line'>             <span class="p">((</span><span class="nv">y-b</span> <span class="p">(</span><span class="nv">to-b</span> <span class="nv">y</span><span class="p">)))</span>
</span><span class='line'>             <span class="p">(</span><span class="nv">mtree-expand</span> <span class="nv">dir</span> <span class="p">((</span><span class="nv">a</span> <span class="nv">x</span> <span class="nv">b</span><span class="p">)</span> <span class="nv">z</span> <span class="p">(</span><span class="nv">c</span> <span class="nv">y-b</span> <span class="nv">d</span><span class="p">)))))</span><span class="nv">&lt;/p&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="nv">&lt;p&gt;</span><span class="p">(</span><span class="nb">defun</span> <span class="nv">insert-oka</span> <span class="p">(</span><span class="nv">root</span> <span class="nv">data</span><span class="p">)</span>
</span><span class='line'>  <span class="p">(</span><span class="k">declare</span> <span class="p">(</span><span class="k">type</span> <span class="kt">fixnum</span> <span class="nv">data</span><span class="p">))</span>
</span><span class='line'>  <span class="p">(</span><span class="nb">cond</span> <span class="p">((</span><span class="nb">null</span> <span class="nv">root</span><span class="p">)</span> <span class="o">`</span><span class="p">(</span><span class="no">nil</span> <span class="o">,</span><span class="p">(</span><span class="nv">make-rb</span> <span class="ss">:data</span> <span class="nv">data</span><span class="p">)</span> <span class="no">nil</span><span class="p">))</span>
</span><span class='line'>        <span class="p">((</span><span class="nb">=</span> <span class="p">(</span><span class="nv">node-data</span> <span class="nv">root</span><span class="p">)</span> <span class="nv">data</span><span class="p">)</span> <span class="nv">root</span><span class="p">)</span>
</span><span class='line'>        <span class="p">(</span><span class="no">T</span> <span class="p">(</span><span class="k">let*</span> <span class="p">((</span><span class="nv">dir</span> <span class="p">(</span><span class="nv">&amp;gt</span><span class="c1">; data (node-data root)))</span>
</span><span class='line'>                 <span class="p">(</span><span class="nv">a</span> <span class="p">(</span><span class="nv">kid</span> <span class="nv">root</span> <span class="p">(</span><span class="nb">not</span> <span class="nv">dir</span><span class="p">)))</span>
</span><span class='line'>                 <span class="p">(</span><span class="nv">b</span> <span class="p">(</span><span class="nv">insert-oka</span> <span class="p">(</span><span class="nv">kid</span> <span class="nv">root</span> <span class="nv">dir</span><span class="p">)</span> <span class="nv">data</span><span class="p">))</span>
</span><span class='line'>                 <span class="p">(</span><span class="nv">root</span> <span class="p">(</span><span class="k">if</span> <span class="nv">dir</span> <span class="p">(</span><span class="nb">list</span> <span class="nv">a</span> <span class="p">(</span><span class="nb">cadr</span> <span class="nv">root</span><span class="p">)</span> <span class="nv">b</span><span class="p">)</span> <span class="p">(</span><span class="nb">list</span> <span class="nv">b</span> <span class="p">(</span><span class="nb">cadr</span> <span class="nv">root</span><span class="p">)</span> <span class="nv">a</span><span class="p">))))</span>
</span><span class='line'>            <span class="p">(</span><span class="nb">cond</span> <span class="p">((</span><span class="nv">is-red</span> <span class="nv">root</span><span class="p">)</span> <span class="nv">root</span><span class="p">)</span>
</span><span class='line'>                  <span class="p">((</span><span class="nb">and</span> <span class="p">(</span><span class="nv">is-red</span> <span class="nv">b</span><span class="p">)</span> <span class="p">(</span><span class="nv">is-red</span> <span class="p">(</span><span class="nv">kid</span> <span class="nv">b</span> <span class="nv">dir</span><span class="p">)))</span> <span class="p">(</span><span class="nv">balance-o</span> <span class="nv">root</span> <span class="nv">dir</span><span class="p">))</span>
</span><span class='line'>                  <span class="p">((</span><span class="nb">and</span> <span class="p">(</span><span class="nv">is-red</span> <span class="nv">b</span><span class="p">)</span> <span class="p">(</span><span class="nv">is-red</span> <span class="p">(</span><span class="nv">kid</span> <span class="nv">b</span> <span class="p">(</span><span class="nb">not</span> <span class="nv">dir</span><span class="p">))))</span> <span class="p">(</span><span class="nv">balance-i</span> <span class="nv">root</span> <span class="nv">dir</span><span class="p">))</span>
</span><span class='line'>                  <span class="p">(</span><span class="no">T</span> <span class="nv">root</span><span class="p">))))))</span><span class="nv">&lt;/p&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="nv">&lt;p&gt;</span><span class="p">(</span><span class="nb">defparameter</span> <span class="nv">&lt;em&gt;tree&lt;/em&gt;</span> <span class="no">nil</span><span class="p">)</span>
</span><span class='line'><span class="p">(</span><span class="nb">defun</span> <span class="nv">rb-insert</span> <span class="p">(</span><span class="nv">data</span><span class="p">)</span>
</span><span class='line'>  <span class="p">(</span><span class="k">declare</span> <span class="p">(</span><span class="k">type</span> <span class="kt">fixnum</span> <span class="nv">data</span><span class="p">))</span>
</span><span class='line'>  <span class="p">(</span><span class="k">setq</span> <span class="nv">&lt;em&gt;tree&lt;/em&gt;</span> <span class="p">(</span><span class="nv">insert-oka</span> <span class="nv">&lt;em&gt;tree&lt;/em&gt;</span> <span class="nv">data</span><span class="p">)))</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>To test the running time:
<div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class='cl'><span class='line'><span class="p">(</span><span class="nb">time</span> <span class="p">(</span><span class="nb">loop</span> <span class="nv">for</span> <span class="nv">i</span> <span class="nv">from</span> <span class="mi">1</span> <span class="nv">to</span> <span class="mi">1000000</span> <span class="nb">do</span> <span class="p">(</span><span class="nv">rb-insert</span> <span class="nv">i</span><span class="p">)))</span><span class="nv">&lt;/p&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="nv">&lt;p&gt;</span><span class="c1">;; The original algorithm using rotate-s and rotate-d</span>
</span><span class='line'>  <span class="mf">19.796</span> <span class="nv">seconds</span> <span class="nv">of</span> <span class="nc">real</span> <span class="nb">time</span>
</span><span class='line'>  <span class="mf">18.570645</span> <span class="nv">seconds</span> <span class="nv">of</span> <span class="nv">total</span> <span class="nv">run</span> <span class="nb">time</span> <span class="p">(</span><span class="mf">17.423563</span> <span class="nv">user,</span> <span class="mf">1.147082</span> <span class="nv">system</span><span class="p">)</span>
</span><span class='line'>  <span class="nv">[</span> <span class="nv">Run</span> <span class="nv">times</span> <span class="nv">consist</span> <span class="nv">of</span> <span class="mf">3.043</span> <span class="nv">seconds</span> <span class="nv">GC</span> <span class="nv">time,</span> <span class="nb">and</span> <span class="mf">15.528</span> <span class="nv">seconds</span> <span class="nv">non-GC</span> <span class="nv">time.</span> <span class="nv">]</span>
</span><span class='line'>  <span class="nv">93.81%</span> <span class="nv">CPU</span>
</span><span class='line'>  <span class="mi">47</span><span class="o">,</span><span class="mi">299</span><span class="o">,</span><span class="mi">915</span><span class="o">,</span><span class="mi">377</span> <span class="nv">processor</span> <span class="nv">cycles</span>
</span><span class='line'>  <span class="mi">6</span><span class="o">,</span><span class="mi">522</span><span class="o">,</span><span class="mi">724</span><span class="o">,</span><span class="mi">144</span> <span class="nv">bytes</span> <span class="nv">consed&lt;/p&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="nv">&lt;p&gt;</span><span class="c1">;; The Okasaki’s algorithm</span>
</span><span class='line'>  <span class="mf">13.005</span> <span class="nv">seconds</span> <span class="nv">of</span> <span class="nc">real</span> <span class="nb">time</span>
</span><span class='line'>  <span class="mf">12.193227</span> <span class="nv">seconds</span> <span class="nv">of</span> <span class="nv">total</span> <span class="nv">run</span> <span class="nb">time</span> <span class="p">(</span><span class="mf">11.213534</span> <span class="nv">user,</span> <span class="mf">0.979693</span> <span class="nv">system</span><span class="p">)</span>
</span><span class='line'>  <span class="nv">[</span> <span class="nv">Run</span> <span class="nv">times</span> <span class="nv">consist</span> <span class="nv">of</span> <span class="mf">2.513</span> <span class="nv">seconds</span> <span class="nv">GC</span> <span class="nv">time,</span> <span class="nb">and</span> <span class="mf">9.681</span> <span class="nv">seconds</span> <span class="nv">non-GC</span> <span class="nv">time.</span> <span class="nv">]</span>
</span><span class='line'>  <span class="nv">93.76%</span> <span class="nv">CPU</span>
</span><span class='line'>  <span class="mi">31</span><span class="o">,</span><span class="mi">073</span><span class="o">,</span><span class="mi">022</span><span class="o">,</span><span class="mi">018</span> <span class="nv">processor</span> <span class="nv">cycles</span>
</span><span class='line'>  <span class="mi">4</span><span class="o">,</span><span class="mi">278</span><span class="o">,</span><span class="mi">336</span><span class="o">,</span><span class="mi">384</span> <span class="nv">bytes</span> <span class="nv">consed</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<h2 id="conclusions">Conclusions</h2>

<p>Lisp is designed for bottom-up programming. You first draft what you want to do,
then you can start to write some functions and macros to simplify it. When there
are more and more utilities you written, you can use it to experiment more
complicated algorithms, in a more elegant and self expressive style.</p>

<p>In purely functional structure, Haskell code  seems to be more elegant because
it has built in pattern matching, while we have to write one for Lisp. But Lisp
provides things more than functional programming, it can also be written in
procedure style, object-oriented style, or any other DSL that is best suitable
for your objective.</p>

<p>The macro system in lisp can also improve your thinking of designing a program.
Because you can always abstract your program structure as you writing it. In
other language you are trained to think top-down, while in lisp you are
encouraged to think back and forth. This process can shorten required time to
get enough experiences of programming. You don’t need a lot experiences to build
a complex algorithm in a bottom-up design process. It’s just come up naturally.</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[persistent red black tree in lisp (3)]]></title>
    <link href="http://www.idryman.org/blog/2012/03/31/persistent-red-black-tree-in-lisp-3/"/>
    <updated>2012-03-31T16:33:00-07:00</updated>
    <id>http://www.idryman.org/blog/2012/03/31/persistent-red-black-tree-in-lisp-3</id>
    <content type="html"><![CDATA[<h2 id="red-black-tree-algorithms">Red black tree algorithms</h2>

<p>There are two good articles that have good explanation on red-black tree
algorithms. For your references:</p>

<ol>
  <li><a href="http://eternallyconfuzzled.com/tuts/datastructures/jsw_tut_rbtree.aspx">Julienne Walker’s red black tree tutorial</a></li>
  <li><a href="http://www.mew.org/~kazu/proj/red-black-tree/">Kazu Yamamoto’s purely functional left-leaning red black trees</a></li>
</ol>

<p>Julienne wrote a beautiful review article that show us not only the algorithm of
red black tree, but <em>how it is designed like so</em>. He also implemented an elegant
C program that can balance the tree in bottom-up or top-down ways. My previous
function <code>(kid root dir dir)</code> was inspired from his implementation.</p>

<p>Kazu reorganized several red black tree insertion algorithms, including Chris
Okasaki’s purely functional way. He also introduced a left-leaning insertion
algorithm that reduces one pattern matching compare to Okasaki’s one. The
programs are elegantly written in Haskell.</p>

<!-- more -->

<h3 id="orinal-red-black-tree-algorithm">Orinal red black tree algorithm</h3>

<p>In 1979, Guibas and Sedgewick published the original imperative red black trees:</p>

<pre><code>Leo J. Guibas and Robert Sedgewick.
"A dichromatic framework for balanced trees",
In Proceedings of the 19th Annual Symposium on Computer Science,
pp8-21,
IEEE Computer Society,
1978
</code></pre>

<p>The original one has eight <em>unbalanced</em> cases to deal with, while two are
reduced in “Introduction to Algorithms”. The algorithm was derived from
symmetric binary B-tree (2-3-4 tree) which was suggested by Rudof Bayer. All
paths from the root to a leaf in a SBB-tree contains the same number of nodes,
thus make it a perfectly balanced tree. However, it is not a binary search tree.
So Rober Sedgewick and Leonidas Guibas came up with a mnemonic abstraction that
can use red-nodes and black-nodes of a binary tree to simulate SBB-Tree. This is
how the algorithm is formed. To know the details, see 
<a href="http://eternallyconfuzzled.com/tuts/datastructures/jsw_tut_rbtree.aspx">Julienne’s guide</a>.</p>

<p>Julienne modified the original bottom up algorithm to a no parent pointers
style:</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><figcaption><span>Julienne’s red black tree insert implementation  </span></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="k">struct</span> <span class="n">jsw_node</span> <span class="o">*</span><span class="nf">jsw_single</span> <span class="p">(</span> <span class="k">struct</span> <span class="n">jsw_node</span> <span class="o">*</span><span class="n">root</span><span class="p">,</span> <span class="kt">int</span> <span class="n">dir</span> <span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="k">struct</span> <span class="n">jsw_node</span> <span class="o">*</span><span class="n">save</span> <span class="o">=</span> <span class="n">root</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">link</span><span class="p">[</span><span class="o">!</span><span class="n">dir</span><span class="p">];</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="n">root</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">link</span><span class="p">[</span><span class="o">!</span><span class="n">dir</span><span class="p">]</span> <span class="o">=</span> <span class="n">save</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">link</span><span class="p">[</span><span class="n">dir</span><span class="p">];</span>
</span><span class='line'>  <span class="n">save</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">link</span><span class="p">[</span><span class="n">dir</span><span class="p">]</span> <span class="o">=</span> <span class="n">root</span><span class="p">;</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="n">root</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">red</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>  <span class="c1">// Note that there’s color changing here!</span>
</span><span class='line'>  <span class="n">save</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">red</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="k">return</span> <span class="n">save</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="k">struct</span> <span class="n">jsw_node</span> <span class="o">*</span><span class="n">jsw_double</span> <span class="p">(</span> <span class="k">struct</span> <span class="n">jsw_node</span> <span class="o">*</span><span class="n">root</span><span class="p">,</span> <span class="kt">int</span> <span class="n">dir</span> <span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="n">root</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">link</span><span class="p">[</span><span class="o">!</span><span class="n">dir</span><span class="p">]</span> <span class="o">=</span> <span class="n">jsw_single</span> <span class="p">(</span> <span class="n">root</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">link</span><span class="p">[</span><span class="o">!</span><span class="n">dir</span><span class="p">],</span> <span class="o">!</span><span class="n">dir</span> <span class="p">);</span>
</span><span class='line'>  <span class="k">return</span> <span class="n">jsw_single</span> <span class="p">(</span> <span class="n">root</span><span class="p">,</span> <span class="n">dir</span> <span class="p">);</span>
</span><span class='line'><span class="p">}</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="k">struct</span> <span class="n">jsw_node</span> <span class="o">*</span><span class="n">jsw_insert_r</span> <span class="p">(</span> <span class="k">struct</span> <span class="n">jsw_node</span> <span class="o">*</span><span class="n">root</span><span class="p">,</span> <span class="kt">int</span> <span class="n">data</span> <span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="k">if</span> <span class="p">(</span> <span class="n">root</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="p">)</span>
</span><span class='line'>    <span class="n">root</span> <span class="o">=</span> <span class="n">make_node</span> <span class="p">(</span> <span class="n">data</span> <span class="p">);</span>
</span><span class='line'>  <span class="k">else</span> <span class="k">if</span> <span class="p">(</span> <span class="n">data</span> <span class="o">!=</span> <span class="n">root</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">data</span> <span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="kt">int</span> <span class="n">dir</span> <span class="o">=</span> <span class="n">root</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">data</span> <span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span> <span class="n">data</span><span class="p">;</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="n">root</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">link</span><span class="p">[</span><span class="n">dir</span><span class="p">]</span> <span class="o">=</span> <span class="n">jsw_insert_r</span> <span class="p">(</span> <span class="n">root</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">link</span><span class="p">[</span><span class="n">dir</span><span class="p">],</span> <span class="n">data</span> <span class="p">);</span>
</span><span class='line'>
</span><span class='line'><span class="k">if</span> <span class="p">(</span> <span class="n">is_red</span> <span class="p">(</span> <span class="n">root</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">link</span><span class="p">[</span><span class="n">dir</span><span class="p">]</span> <span class="p">)</span> <span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">if</span> <span class="p">(</span> <span class="n">is_red</span> <span class="p">(</span> <span class="n">root</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">link</span><span class="p">[</span><span class="o">!</span><span class="n">dir</span><span class="p">]</span> <span class="p">)</span> <span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="cm">/* Case 1 Color flip */</span>
</span><span class='line'>    <span class="n">root</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">red</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span><span class='line'>    <span class="n">root</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">link</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">red</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'>    <span class="n">root</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">link</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">red</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>  <span class="k">else</span> <span class="p">{</span>
</span><span class='line'>    <span class="cm">/* Cases 2 &amp;amp; 3 */</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span> <span class="n">is_red</span> <span class="p">(</span> <span class="n">root</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">link</span><span class="p">[</span><span class="n">dir</span><span class="p">]</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">link</span><span class="p">[</span><span class="n">dir</span><span class="p">]</span> <span class="p">)</span> <span class="p">)</span>
</span><span class='line'>      <span class="n">root</span> <span class="o">=</span> <span class="n">jsw_single</span> <span class="p">(</span> <span class="n">root</span><span class="p">,</span> <span class="o">!</span><span class="n">dir</span> <span class="p">);</span>
</span><span class='line'>    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span> <span class="n">is_red</span> <span class="p">(</span> <span class="n">root</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">link</span><span class="p">[</span><span class="n">dir</span><span class="p">]</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">link</span><span class="p">[</span><span class="o">!</span><span class="n">dir</span><span class="p">]</span> <span class="p">)</span> <span class="p">)</span>
</span><span class='line'>      <span class="n">root</span> <span class="o">=</span> <span class="n">jsw_double</span> <span class="p">(</span> <span class="n">root</span><span class="p">,</span> <span class="o">!</span><span class="n">dir</span> <span class="p">);</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">}</span>   <span class="p">}</span>
</span><span class='line'><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="k">return</span> <span class="n">root</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="kt">int</span> <span class="n">jsw_insert</span> <span class="p">(</span> <span class="k">struct</span> <span class="n">jsw_tree</span> <span class="o">*</span><span class="n">tree</span><span class="p">,</span> <span class="kt">int</span> <span class="n">data</span> <span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="n">tree</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">root</span> <span class="o">=</span> <span class="n">jsw_insert_r</span> <span class="p">(</span> <span class="n">tree</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">root</span><span class="p">,</span> <span class="n">data</span> <span class="p">);</span>
</span><span class='line'>  <span class="n">tree</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">root</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">red</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'>  <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<h3 id="implementation-in-lisp">Implementation in Lisp</h3>

<p>Julienne’s bottom-up algorithm can be easily to be re-written in purely
functional style. The ugly part is the color flipping and assign new branches to
nodes.</p>

<p>Though we can do the color flipping as</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='cl'><span class='line'><span class="p">(</span><span class="nb">setf</span> <span class="p">(</span><span class="nv">rb-red</span> <span class="p">(</span><span class="nb">cadr</span> <span class="nv">root</span><span class="p">))</span> <span class="no">nil</span>
</span><span class='line'>      <span class="p">(</span><span class="nv">rb-red</span> <span class="p">(</span><span class="nb">cadr</span> <span class="nv">a</span><span class="p">))</span> <span class="no">T</span>
</span><span class='line'>      <span class="p">(</span><span class="nv">rb-red</span> <span class="p">(</span><span class="nb">cadr</span> <span class="nv">b</span><span class="p">))</span> <span class="no">T</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>but the tree would be non-persistent. So we need to create new node with new
property of red or black.</p>

<p>I also separate the cases into two function <code>color-flip</code> and
<code>rb-insert-case-rest</code>. Thus the code would be easier to debug and profile.</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
</pre></td><td class='code'><pre><code class='cl'><span class='line'><span class="p">(</span><span class="nb">defun</span> <span class="nv">rotate-s</span> <span class="p">(</span><span class="nv">node</span> <span class="nv">dir</span><span class="p">)</span>
</span><span class='line'>  <span class="p">(</span><span class="nv">mtree-let</span> <span class="nv">dir</span> <span class="nv">node</span> <span class="p">((</span><span class="nv">a</span> <span class="nv">y</span> <span class="nv">b</span><span class="p">)</span> <span class="nv">x</span> <span class="nv">c</span><span class="p">)</span>
</span><span class='line'>            <span class="p">((</span><span class="nv">x-r</span> <span class="p">(</span><span class="nv">to-r</span> <span class="nv">x</span><span class="p">))</span> <span class="p">(</span><span class="nv">y-b</span> <span class="p">(</span><span class="nv">to-b</span> <span class="nv">y</span><span class="p">)))</span>
</span><span class='line'>            <span class="p">(</span><span class="nv">mtree-expand</span> <span class="nv">dir</span> <span class="p">(</span><span class="nv">a</span> <span class="nv">y-b</span> <span class="p">(</span><span class="nv">b</span> <span class="nv">x-r</span> <span class="nv">c</span><span class="p">)))))</span><span class="nv">&lt;/p&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="nv">&lt;p&gt;</span><span class="p">(</span><span class="nb">defun</span> <span class="nv">rotate-d</span> <span class="p">(</span><span class="nv">node</span> <span class="nv">dir</span><span class="p">)</span>
</span><span class='line'>  <span class="p">(</span><span class="nv">mtree-let</span> <span class="nv">dir</span> <span class="nv">node</span> <span class="p">(</span><span class="nv">a</span> <span class="nv">x</span> <span class="nv">b</span><span class="p">)</span>
</span><span class='line'>            <span class="p">((</span><span class="nv">a-new</span> <span class="p">(</span><span class="nv">rotate-s</span> <span class="nv">a</span> <span class="p">(</span><span class="nb">not</span> <span class="nv">dir</span><span class="p">))))</span>
</span><span class='line'>            <span class="p">(</span><span class="nv">rotate-s</span> <span class="p">(</span><span class="nv">mtree-expand</span> <span class="nv">dir</span> <span class="p">(</span><span class="nv">a-new</span> <span class="nv">x</span> <span class="nv">b</span><span class="p">))</span> <span class="nv">dir</span><span class="p">)))</span><span class="nv">&lt;/p&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="nv">&lt;p&gt;</span><span class="c1">;; Color flipping utilities </span>
</span><span class='line'><span class="p">(</span><span class="nb">defun</span> <span class="nv">to-r</span> <span class="p">(</span><span class="nv">x</span><span class="p">)</span> <span class="p">(</span><span class="nv">make-rb</span> <span class="ss">:data</span> <span class="p">(</span><span class="nv">rb-data</span> <span class="nv">x</span><span class="p">)</span> <span class="ss">:red</span> <span class="no">T</span><span class="p">))</span>
</span><span class='line'><span class="p">(</span><span class="nb">defun</span> <span class="nv">to-b</span> <span class="p">(</span><span class="nv">x</span><span class="p">)</span> <span class="p">(</span><span class="nv">make-rb</span> <span class="ss">:data</span> <span class="p">(</span><span class="nv">rb-data</span> <span class="nv">x</span><span class="p">)</span> <span class="ss">:red</span> <span class="no">nil</span><span class="p">))</span><span class="nv">&lt;/p&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="nv">&lt;p&gt;</span><span class="p">(</span><span class="nb">defun</span> <span class="nv">color-flip</span> <span class="p">(</span><span class="nv">root</span> <span class="nv">dir</span><span class="p">)</span>
</span><span class='line'>  <span class="p">(</span><span class="nv">mtree-let</span> <span class="nv">dir</span> <span class="nv">root</span> <span class="p">((</span><span class="nv">a</span> <span class="nv">y</span> <span class="nv">b</span><span class="p">)</span> <span class="nv">x</span> <span class="p">(</span><span class="nv">c</span> <span class="nv">z</span> <span class="nv">d</span><span class="p">))</span>
</span><span class='line'>             <span class="p">((</span><span class="nv">x-r</span> <span class="p">(</span><span class="nv">to-r</span> <span class="nv">x</span><span class="p">))</span>
</span><span class='line'>              <span class="p">(</span><span class="nv">y-b</span> <span class="p">(</span><span class="nv">to-b</span> <span class="nv">y</span><span class="p">))</span>
</span><span class='line'>              <span class="p">(</span><span class="nv">z-b</span> <span class="p">(</span><span class="nv">to-b</span> <span class="nv">z</span><span class="p">)))</span>
</span><span class='line'>             <span class="p">(</span><span class="nv">mtree-expand</span> <span class="nv">dir</span> <span class="p">((</span><span class="nv">a</span> <span class="nv">y-b</span> <span class="nv">b</span><span class="p">)</span> <span class="nv">x-r</span> <span class="p">(</span><span class="nv">c</span> <span class="nv">z-b</span> <span class="nv">d</span><span class="p">)))))</span><span class="nv">&lt;/p&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="nv">&lt;p&gt;</span><span class="p">(</span><span class="nb">defun</span> <span class="nv">rb-insert-case-rest</span> <span class="p">(</span><span class="nv">root</span> <span class="nv">dir</span><span class="p">)</span>
</span><span class='line'>  <span class="p">(</span><span class="nb">cond</span> <span class="p">((</span><span class="nv">is-red</span> <span class="p">(</span><span class="nv">kid</span> <span class="nv">root</span> <span class="nv">dir</span> <span class="nv">dir</span><span class="p">))</span> <span class="p">(</span><span class="nv">rotate-s</span> <span class="nv">root</span> <span class="p">(</span><span class="nb">not</span> <span class="nv">dir</span><span class="p">)))</span>
</span><span class='line'>        <span class="p">((</span><span class="nv">is-red</span> <span class="p">(</span><span class="nv">kid</span> <span class="nv">root</span> <span class="nv">dir</span> <span class="p">(</span><span class="nb">not</span> <span class="nv">dir</span><span class="p">)))</span> <span class="p">(</span><span class="nv">rotate-d</span> <span class="nv">root</span> <span class="p">(</span><span class="nb">not</span> <span class="nv">dir</span><span class="p">)))</span>
</span><span class='line'>        <span class="p">(</span><span class="no">T</span> <span class="nv">root</span><span class="p">)))</span><span class="nv">&lt;/p&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="nv">&lt;p&gt;</span><span class="p">(</span><span class="nb">defun</span> <span class="nv">rb-insert-r</span> <span class="p">(</span><span class="nv">root</span> <span class="nv">data</span><span class="p">)</span>
</span><span class='line'>  <span class="p">(</span><span class="k">declare</span> <span class="p">(</span><span class="k">type</span> <span class="kt">fixnum</span> <span class="nv">data</span><span class="p">))</span>
</span><span class='line'>  <span class="p">(</span><span class="nb">cond</span> <span class="p">((</span><span class="nb">null</span> <span class="nv">root</span><span class="p">)</span> <span class="o">`</span><span class="p">(</span><span class="no">nil</span> <span class="o">,</span><span class="p">(</span><span class="nv">make-rb</span> <span class="ss">:data</span> <span class="nv">data</span><span class="p">)</span> <span class="no">nil</span><span class="p">))</span>
</span><span class='line'>        <span class="p">((</span><span class="nb">=</span> <span class="nv">data</span> <span class="p">(</span><span class="nv">node-data</span> <span class="nv">root</span><span class="p">))</span> <span class="nv">root</span><span class="p">)</span>
</span><span class='line'>        <span class="p">(</span><span class="no">T</span> <span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="nv">dir</span> <span class="p">(</span><span class="nv">&amp;gt</span><span class="c1">; data (node-data root))))</span>
</span><span class='line'>             <span class="p">(</span><span class="nv">mtree-let</span> <span class="nv">dir</span> <span class="nv">root</span> <span class="p">(</span><span class="nv">a</span> <span class="nv">x</span> <span class="nv">b</span><span class="p">)</span>
</span><span class='line'>               <span class="p">((</span><span class="nv">b</span> <span class="p">(</span><span class="nv">rb-insert-r</span> <span class="nv">b</span> <span class="nv">data</span><span class="p">))</span>
</span><span class='line'>                <span class="p">(</span><span class="nv">root</span> <span class="p">(</span><span class="nv">mtree-expand</span> <span class="nv">dir</span> <span class="p">(</span><span class="nv">a</span> <span class="nv">x</span> <span class="nv">b</span><span class="p">))))</span>
</span><span class='line'>               <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nv">is-red</span> <span class="nv">b</span><span class="p">)</span>
</span><span class='line'>                 <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nv">is-red</span> <span class="nv">a</span><span class="p">)</span>
</span><span class='line'>                   <span class="p">(</span><span class="nv">color-flip</span> <span class="nv">root</span> <span class="nv">dir</span><span class="p">)</span>            <span class="c1">; case 1</span>
</span><span class='line'>                   <span class="p">(</span><span class="nv">rb-insert-case-rest</span> <span class="nv">root</span> <span class="nv">dir</span><span class="p">))</span>  <span class="c1">; case 2 and 3</span>
</span><span class='line'>                 <span class="nv">root</span><span class="p">))))))</span><span class="nv">&lt;/p&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="nv">&lt;p&gt;</span><span class="p">(</span><span class="nb">defparameter</span> <span class="nv">&lt;em&gt;tree&lt;/em&gt;</span> <span class="no">nil</span><span class="p">)</span>
</span><span class='line'><span class="p">(</span><span class="nb">defun</span> <span class="nv">rb-insert</span> <span class="p">(</span><span class="nv">data</span><span class="p">)</span>
</span><span class='line'>  <span class="p">(</span><span class="k">declare</span> <span class="p">(</span><span class="k">type</span> <span class="kt">fixnum</span> <span class="nv">data</span><span class="p">))</span>
</span><span class='line'>  <span class="p">(</span><span class="k">let*</span> <span class="p">((</span><span class="nv">ret</span> <span class="p">(</span><span class="nv">rb-insert-r</span> <span class="nv">&lt;em&gt;tree&lt;/em&gt;</span> <span class="nv">data</span><span class="p">))</span>
</span><span class='line'>         <span class="p">(</span><span class="nv">a</span> <span class="p">(</span><span class="nb">car</span> <span class="nv">ret</span><span class="p">))</span>            <span class="c1">;; Set the root node to be black</span>
</span><span class='line'>         <span class="p">(</span><span class="nv">x-b</span> <span class="p">(</span><span class="nv">to-b</span> <span class="p">(</span><span class="nb">cadr</span> <span class="nv">ret</span><span class="p">)))</span>
</span><span class='line'>         <span class="p">(</span><span class="nv">b</span> <span class="p">(</span><span class="nb">caddr</span> <span class="nv">ret</span><span class="p">)))</span>
</span><span class='line'>    <span class="p">(</span><span class="nb">setf</span> <span class="nv">&lt;em&gt;tree&lt;/em&gt;</span> <span class="p">(</span><span class="nb">list</span> <span class="nv">a</span> <span class="nv">x-b</span> <span class="nv">b</span><span class="p">))</span>
</span><span class='line'>    <span class="nv">&lt;em&gt;tree&lt;/em&gt;</span><span class="p">))</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>When the cases in function are separated, it is easy to tell how the program is being called:</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
</pre></td><td class='code'><pre><code class='cl'><span class='line'><span class="nv">CL-USER&amp;gt</span><span class="c1">; (trace rb-insert-r rb-insert-case-rest color-flip rotate-s rotate-d)&lt;/p&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="nv">&lt;p&gt;CL-USER&amp;gt</span><span class="c1">; (rb-insert 3)</span>
</span><span class='line'>  <span class="nv">0:</span> <span class="p">(</span><span class="nv">RB-INSERT-R</span> <span class="p">((</span><span class="no">NIL</span> <span class="nv">5-b</span> <span class="no">NIL</span><span class="p">)</span> <span class="nv">6-b</span> <span class="p">(</span><span class="no">NIL</span> <span class="nv">7-b</span> <span class="p">(</span><span class="no">NIL</span> <span class="nv">8-r</span> <span class="no">NIL</span><span class="p">)))</span> <span class="mi">3</span><span class="p">)</span>
</span><span class='line'>    <span class="nv">1:</span> <span class="p">(</span><span class="nv">RB-INSERT-CASE-REST</span> <span class="p">((</span><span class="no">NIL</span> <span class="nv">3-r</span> <span class="no">NIL</span><span class="p">)</span> <span class="nv">5-b</span> <span class="no">NIL</span><span class="p">)</span> <span class="no">NIL</span><span class="p">)</span>
</span><span class='line'>    <span class="nv">1:</span> <span class="nv">RB-INSERT-CASE-REST</span> <span class="nv">returned</span> <span class="p">((</span><span class="no">NIL</span> <span class="nv">3-r</span> <span class="no">NIL</span><span class="p">)</span> <span class="nv">5-b</span> <span class="no">NIL</span><span class="p">)</span>
</span><span class='line'>  <span class="nv">0:</span> <span class="nv">RB-INSERT-R</span> <span class="nv">returned</span> <span class="p">(((</span><span class="no">NIL</span> <span class="nv">3-r</span> <span class="no">NIL</span><span class="p">)</span> <span class="nv">5-b</span> <span class="no">NIL</span><span class="p">)</span> <span class="nv">6-b</span> <span class="p">(</span><span class="no">NIL</span> <span class="nv">7-b</span> <span class="p">(</span><span class="no">NIL</span> <span class="nv">8-r</span> <span class="no">NIL</span><span class="p">)))</span><span class="nv">&lt;/p&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="nv">&lt;p&gt;CL-USER&amp;gt</span><span class="c1">; (rb-insert 100)</span>
</span><span class='line'>  <span class="nv">0:</span> <span class="p">(</span><span class="nv">RB-INSERT-R</span> <span class="p">(((</span><span class="no">NIL</span> <span class="nv">3-r</span> <span class="no">NIL</span><span class="p">)</span> <span class="nv">5-b</span> <span class="no">NIL</span><span class="p">)</span> <span class="nv">6-b</span> <span class="p">(</span><span class="no">NIL</span> <span class="nv">7-b</span> <span class="p">(</span><span class="no">NIL</span> <span class="nv">8-r</span> <span class="no">NIL</span><span class="p">)))</span> <span class="mi">100</span><span class="p">)</span>
</span><span class='line'>    <span class="nv">1:</span> <span class="p">(</span><span class="nv">RB-INSERT-CASE-REST</span> <span class="p">(</span><span class="no">NIL</span> <span class="nv">8-r</span> <span class="p">(</span><span class="no">NIL</span> <span class="nv">100-r</span> <span class="no">NIL</span><span class="p">))</span> <span class="no">T</span><span class="p">)</span>
</span><span class='line'>    <span class="nv">1:</span> <span class="nv">RB-INSERT-CASE-REST</span> <span class="nv">returned</span> <span class="p">(</span><span class="no">NIL</span> <span class="nv">8-r</span> <span class="p">(</span><span class="no">NIL</span> <span class="nv">100-r</span> <span class="no">NIL</span><span class="p">))</span>
</span><span class='line'>    <span class="nv">1:</span> <span class="p">(</span><span class="nv">RB-INSERT-CASE-REST</span> <span class="p">(</span><span class="no">NIL</span> <span class="nv">7-b</span> <span class="p">(</span><span class="no">NIL</span> <span class="nv">8-r</span> <span class="p">(</span><span class="no">NIL</span> <span class="nv">100-r</span> <span class="no">NIL</span><span class="p">)))</span> <span class="no">T</span><span class="p">)</span>
</span><span class='line'>      <span class="nv">2:</span> <span class="p">(</span><span class="nv">ROTATE-S</span> <span class="p">(</span><span class="no">NIL</span> <span class="nv">7-b</span> <span class="p">(</span><span class="no">NIL</span> <span class="nv">8-r</span> <span class="p">(</span><span class="no">NIL</span> <span class="nv">100-r</span> <span class="no">NIL</span><span class="p">)))</span> <span class="no">NIL</span><span class="p">)</span>
</span><span class='line'>      <span class="nv">2:</span> <span class="nv">ROTATE-S</span> <span class="nv">returned</span> <span class="p">((</span><span class="no">NIL</span> <span class="nv">7-r</span> <span class="no">NIL</span><span class="p">)</span> <span class="nv">8-b</span> <span class="p">(</span><span class="no">NIL</span> <span class="nv">100-r</span> <span class="no">NIL</span><span class="p">))</span>
</span><span class='line'>    <span class="nv">1:</span> <span class="nv">RB-INSERT-CASE-REST</span> <span class="nv">returned</span> <span class="p">((</span><span class="no">NIL</span> <span class="nv">7-r</span> <span class="no">NIL</span><span class="p">)</span> <span class="nv">8-b</span> <span class="p">(</span><span class="no">NIL</span> <span class="nv">100-r</span> <span class="no">NIL</span><span class="p">))</span>
</span><span class='line'>  <span class="nv">0:</span> <span class="nv">RB-INSERT-R</span> <span class="nv">returned</span>
</span><span class='line'>       <span class="p">(((</span><span class="no">NIL</span> <span class="nv">3-r</span> <span class="no">NIL</span><span class="p">)</span> <span class="nv">5-b</span> <span class="no">NIL</span><span class="p">)</span> <span class="nv">6-b</span> <span class="p">((</span><span class="no">NIL</span> <span class="nv">7-r</span> <span class="no">NIL</span><span class="p">)</span> <span class="nv">8-b</span> <span class="p">(</span><span class="no">NIL</span> <span class="nv">100-r</span> <span class="no">NIL</span><span class="p">)))</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<hr />

<p>I modified the definition of <code>rb</code> structure to make it print prettier:</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='cl'><span class='line'><span class="p">(</span><span class="nb">defstruct</span>
</span><span class='line'>  <span class="p">(</span><span class="nv">rb</span> <span class="p">(</span><span class="ss">:print-function</span>
</span><span class='line'>        <span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nv">p</span> <span class="nv">s</span> <span class="nv">k</span><span class="p">)</span>
</span><span class='line'>          <span class="p">(</span><span class="k">declare</span> <span class="p">(</span><span class="k">ignore</span> <span class="nv">k</span><span class="p">)(</span><span class="k">type</span> <span class="nc">stream</span> <span class="nv">s</span><span class="p">))</span>
</span><span class='line'>          <span class="p">(</span><span class="nb">format</span> <span class="nv">s</span> <span class="err">“</span><span class="nv">~d-~:[b~</span><span class="c1">;r~]” (rb-data p) (rb-red p)))))</span>
</span><span class='line'>  <span class="p">(</span><span class="nv">red</span> <span class="no">T</span> <span class="ss">:read-only</span> <span class="no">T</span><span class="p">)</span>
</span><span class='line'>  <span class="p">(</span><span class="nv">data</span> <span class="mi">0</span> <span class="ss">:type</span> <span class="kt">fixnum</span> <span class="ss">:read-only</span> <span class="no">T</span><span class="p">))</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>So that when <code>Lisp</code> want to print a <code>rb</code> with data is <code>8</code> and red is <code>nil</code>, it
would print <code>8-b</code> instead of <code>#S(RB :data 8 :red nil)</code>.</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[persistent red black tree in lisp (2)]]></title>
    <link href="http://www.idryman.org/blog/2012/03/31/persistent-red-black-tree-in-lisp-2/"/>
    <updated>2012-03-31T09:22:00-07:00</updated>
    <id>http://www.idryman.org/blog/2012/03/31/persistent-red-black-tree-in-lisp-2</id>
    <content type="html"><![CDATA[<h3 id="single-rotate">Single rotate</h3>

<p>Using the <code>kid</code> utility, we can make rotate single to be simpler too:
<div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class='cl'><span class='line'><span class="c1">;;       x              y</span>
</span><span class='line'><span class="c1">;;     /   \          /   \</span>
</span><span class='line'><span class="c1">;;    y     c   =&amp;gt;   a     x     &lt;br /&gt;</span>
</span><span class='line'><span class="c1">;;  /   \                 / \</span>
</span><span class='line'><span class="c1">;; a     b               b   c</span>
</span><span class='line'><span class="c1">;;</span>
</span><span class='line'><span class="p">(</span><span class="nb">defun</span> <span class="nv">rotate-s</span> <span class="p">(</span><span class="nv">root</span> <span class="nv">dir</span><span class="p">)</span>
</span><span class='line'>  <span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="nv">x</span> <span class="p">(</span><span class="nb">cadr</span> <span class="nv">root</span><span class="p">))</span>
</span><span class='line'>        <span class="p">(</span><span class="nv">y</span> <span class="p">(</span><span class="nb">cadr</span> <span class="p">(</span><span class="nv">kid</span> <span class="p">(</span><span class="nb">not</span> <span class="nv">dir</span><span class="p">))))</span>
</span><span class='line'>        <span class="p">(</span><span class="nv">a</span> <span class="p">(</span><span class="nv">kid</span> <span class="p">(</span><span class="nb">not</span> <span class="nv">dir</span><span class="p">)</span> <span class="p">(</span><span class="nb">not</span> <span class="nv">dir</span><span class="p">)))</span>
</span><span class='line'>        <span class="p">(</span><span class="nv">b</span> <span class="p">(</span><span class="nv">kid</span> <span class="p">(</span><span class="nb">not</span> <span class="nv">dir</span><span class="p">)</span> <span class="nv">dir</span><span class="p">))</span>
</span><span class='line'>        <span class="p">(</span><span class="nv">c</span> <span class="p">(</span><span class="nv">kid</span> <span class="nv">dir</span><span class="p">)))</span>
</span><span class='line'>    <span class="p">(</span><span class="k">if</span> <span class="nv">dir</span>
</span><span class='line'>        <span class="p">(</span><span class="nb">list</span> <span class="nv">a</span> <span class="nv">y</span> <span class="p">(</span><span class="nb">list</span> <span class="nv">b</span> <span class="nv">x</span> <span class="nv">c</span><span class="p">))</span>
</span><span class='line'>        <span class="p">(</span><span class="nb">list</span> <span class="p">(</span><span class="nb">list</span> <span class="nv">c</span> <span class="nv">x</span> <span class="nv">b</span><span class="p">)</span> <span class="nv">y</span> <span class="nv">a</span><span class="p">))))</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>Observe that the two return form is nested reversed. Why not write a macro that
generate this form? Then we only need to write the right case!</p>

<!-- more -->

<h3 id="reverse-the-tree">Reverse the tree</h3>

<p>First we need to write a function that take a nested form and return it in
reversed order (also nested.) To achieve this, we use double recursion.</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='cl'><span class='line'><span class="p">(</span><span class="nb">defun</span> <span class="nv">tree-to-rev</span> <span class="p">(</span><span class="nv">tree</span> <span class="nv">acc</span><span class="p">)</span>
</span><span class='line'>   <span class="p">(</span><span class="nb">cond</span> <span class="p">((</span><span class="nb">null</span> <span class="nv">tree</span><span class="p">)</span> <span class="nv">acc</span><span class="p">)</span>
</span><span class='line'>         <span class="p">((</span><span class="nb">consp</span> <span class="p">(</span><span class="nb">car</span> <span class="nv">tree</span><span class="p">))</span>
</span><span class='line'>          <span class="p">(</span><span class="nv">tree-to-rev</span> <span class="p">(</span><span class="nb">cdr</span> <span class="nv">tree</span><span class="p">)</span>
</span><span class='line'>               <span class="p">(</span><span class="nb">cons</span> <span class="p">(</span><span class="nv">tree-to-rev</span> <span class="p">(</span><span class="nb">car</span> <span class="nv">tree</span><span class="p">)</span> <span class="no">nil</span><span class="p">)</span> <span class="nv">acc</span><span class="p">)))</span>
</span><span class='line'>         <span class="p">(</span><span class="no">T</span> <span class="p">(</span><span class="nv">tree-to-rev</span> <span class="p">(</span><span class="nb">cdr</span> <span class="nv">tree</span><span class="p">)</span> <span class="p">(</span><span class="nb">cons</span> <span class="p">(</span><span class="nb">car</span> <span class="nv">tree</span><span class="p">)</span> <span class="nv">acc</span><span class="p">)))))</span><span class="nv">&lt;/p&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="nv">&lt;p&gt;CL-USER&amp;gt</span><span class="c1">; (tree-to-rev ‘(a b (c d e)) nil)</span>
</span><span class='line'><span class="p">((</span><span class="nv">E</span> <span class="nv">D</span> <span class="nv">C</span><span class="p">)</span> <span class="nv">B</span> <span class="nv">A</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>Recall that we need to add <code>list</code> at the beginning of returned form. So rewrite
the function as</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
</pre></td><td class='code'><pre><code class='cl'><span class='line'><span class="p">(</span><span class="nb">defun</span> <span class="nv">tree-to-rev-list</span> <span class="p">(</span><span class="nv">tree</span> <span class="nv">acc</span><span class="p">)</span>
</span><span class='line'>   <span class="p">(</span><span class="nb">cond</span> <span class="p">((</span><span class="nb">null</span> <span class="nv">tree</span><span class="p">)</span> <span class="p">(</span><span class="nb">cons</span> <span class="err">‘</span><span class="nb">list</span> <span class="nv">acc</span><span class="p">))</span>
</span><span class='line'>         <span class="p">((</span><span class="nb">consp</span> <span class="p">(</span><span class="nb">car</span> <span class="nv">tree</span><span class="p">))</span>
</span><span class='line'>          <span class="p">(</span><span class="nv">tree-to-rev-list</span> <span class="p">(</span><span class="nb">cdr</span> <span class="nv">tree</span><span class="p">)</span>
</span><span class='line'>               <span class="p">(</span><span class="nb">cons</span> <span class="p">(</span><span class="nv">tree-to-rev-list</span> <span class="p">(</span><span class="nb">car</span> <span class="nv">tree</span><span class="p">)</span> <span class="no">nil</span><span class="p">)</span> <span class="nv">acc</span><span class="p">)))</span>
</span><span class='line'>         <span class="p">(</span><span class="no">T</span> <span class="p">(</span><span class="nv">tree-to-rev-list</span> <span class="p">(</span><span class="nb">cdr</span> <span class="nv">tree</span><span class="p">)</span> <span class="p">(</span><span class="nb">cons</span> <span class="p">(</span><span class="nb">car</span> <span class="nv">tree</span><span class="p">)</span> <span class="nv">acc</span><span class="p">)))))</span><span class="nv">&lt;/p&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="nv">&lt;p&gt;</span><span class="p">(</span><span class="nb">defun</span> <span class="nv">tree-to-list</span> <span class="p">(</span><span class="nv">tree</span> <span class="nv">acc</span><span class="p">)</span>
</span><span class='line'>   <span class="p">(</span><span class="nb">cond</span> <span class="p">((</span><span class="nb">null</span> <span class="nv">tree</span><span class="p">)</span> <span class="p">(</span><span class="nb">cons</span> <span class="err">‘</span><span class="nb">list</span> <span class="p">(</span><span class="nb">reverse</span> <span class="nv">acc</span><span class="p">)))</span>
</span><span class='line'>         <span class="p">((</span><span class="nb">consp</span> <span class="p">(</span><span class="nb">car</span> <span class="nv">tree</span><span class="p">))</span>
</span><span class='line'>          <span class="p">(</span><span class="nv">tree-to-list</span> <span class="p">(</span><span class="nb">cdr</span> <span class="nv">tree</span><span class="p">)</span>
</span><span class='line'>               <span class="p">(</span><span class="nb">cons</span> <span class="p">(</span><span class="nv">tree-to-list</span> <span class="p">(</span><span class="nb">car</span> <span class="nv">tree</span><span class="p">)</span> <span class="no">nil</span><span class="p">)</span> <span class="nv">acc</span><span class="p">)))</span>
</span><span class='line'>         <span class="p">(</span><span class="no">T</span> <span class="p">(</span><span class="nv">tree-to-list</span> <span class="p">(</span><span class="nb">cdr</span> <span class="nv">tree</span><span class="p">)</span> <span class="p">(</span><span class="nb">cons</span> <span class="p">(</span><span class="nb">car</span> <span class="nv">tree</span><span class="p">)</span> <span class="nv">acc</span><span class="p">)))))</span><span class="nv">&lt;/p&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="nv">&lt;p&gt;CL-USER&amp;gt</span><span class="c1">; (tree-to-rev-list ‘(a b (c d e)) nil)</span>
</span><span class='line'><span class="p">(</span><span class="nv">LIST</span> <span class="p">(</span><span class="nv">LIST</span> <span class="nv">E</span> <span class="nv">D</span> <span class="nv">C</span><span class="p">)</span> <span class="nv">B</span> <span class="nv">A</span><span class="p">)</span><span class="nv">&lt;/p&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="nv">&lt;p&gt;CL-USER&amp;gt</span><span class="c1">; (tree-to-list ‘(a b (c d e)) nil)</span>
</span><span class='line'><span class="p">(</span><span class="nv">LIST</span> <span class="nv">A</span> <span class="nv">B</span> <span class="p">(</span><span class="nv">LIST</span> <span class="nv">C</span> <span class="nv">D</span> <span class="nv">E</span><span class="p">))</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<h3 id="macro-that-simplify-the-return-form">Macro that simplify the return form</h3>

<p>Now we write a macro that we only need to pass it the right case:</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='cl'><span class='line'><span class="p">(</span><span class="nb">defmacro</span> <span class="nv">mtree-expand</span> <span class="p">(</span><span class="nv">dir</span> <span class="nv">tree</span><span class="p">)</span>
</span><span class='line'>  <span class="o">`</span><span class="p">(</span><span class="k">if</span> <span class="o">,</span><span class="nv">dir</span>
</span><span class='line'>      <span class="o">,</span><span class="p">(</span><span class="nv">tree-to-list</span> <span class="nv">tree</span> <span class="no">nil</span><span class="p">)</span>
</span><span class='line'>      <span class="o">,</span><span class="p">(</span><span class="nv">tree-to-rev-list</span> <span class="nv">tree</span> <span class="no">nil</span><span class="p">)))</span><span class="nv">&lt;/p&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="nv">&lt;p&gt;CL-USER&amp;gt</span><span class="c1">; (macroexpand-1 ‘(mtree-expand dir (a y (b x c))))</span>
</span><span class='line'><span class="p">(</span><span class="nv">IF</span> <span class="nv">DIR</span>
</span><span class='line'>    <span class="p">(</span><span class="nv">LIST</span> <span class="nv">A</span> <span class="nv">Y</span> <span class="p">(</span><span class="nv">LIST</span> <span class="nv">B</span> <span class="nv">X</span> <span class="nv">C</span><span class="p">))</span>
</span><span class='line'>    <span class="p">(</span><span class="nv">LIST</span> <span class="p">(</span><span class="nv">LIST</span> <span class="nv">C</span> <span class="nv">X</span> <span class="nv">B</span><span class="p">)</span> <span class="nv">Y</span> <span class="nv">A</span><span class="p">))</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>Now the <code>insert-binary-r</code> and <code>rotate-s</code> can be re-written only in right form!</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
</pre></td><td class='code'><pre><code class='cl'><span class='line'><span class="c1">;;       x              y</span>
</span><span class='line'><span class="c1">;;     /   \          /   \</span>
</span><span class='line'><span class="c1">;;    y     c   =&amp;gt;   a     x     &lt;br /&gt;</span>
</span><span class='line'><span class="c1">;;  /   \                 / \</span>
</span><span class='line'><span class="c1">;; a     b               b   c</span>
</span><span class='line'><span class="c1">;;</span>
</span><span class='line'><span class="p">(</span><span class="nb">defun</span> <span class="nv">rotate-s</span> <span class="p">(</span><span class="nv">root</span> <span class="nv">dir</span><span class="p">)</span>
</span><span class='line'>  <span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="nv">x</span> <span class="p">(</span><span class="nb">cadr</span> <span class="nv">root</span><span class="p">))</span>
</span><span class='line'>        <span class="p">(</span><span class="nv">y</span> <span class="p">(</span><span class="nb">cadr</span> <span class="p">(</span><span class="nv">kid</span> <span class="p">(</span><span class="nb">not</span> <span class="nv">dir</span><span class="p">))))</span>
</span><span class='line'>        <span class="p">(</span><span class="nv">a</span> <span class="p">(</span><span class="nv">kid</span> <span class="p">(</span><span class="nb">not</span> <span class="nv">dir</span><span class="p">)</span> <span class="p">(</span><span class="nb">not</span> <span class="nv">dir</span><span class="p">)))</span>
</span><span class='line'>        <span class="p">(</span><span class="nv">b</span> <span class="p">(</span><span class="nv">kid</span> <span class="p">(</span><span class="nb">not</span> <span class="nv">dir</span><span class="p">)</span> <span class="nv">dir</span><span class="p">))</span>
</span><span class='line'>        <span class="p">(</span><span class="nv">c</span> <span class="p">(</span><span class="nv">kid</span> <span class="nv">dir</span><span class="p">)))</span>
</span><span class='line'>    <span class="p">(</span><span class="nv">mtree-expand</span> <span class="nv">dir</span> <span class="p">(</span><span class="nv">a</span> <span class="nv">y</span> <span class="p">(</span><span class="nv">b</span> <span class="nv">x</span> <span class="nv">c</span><span class="p">)))))</span><span class="nv">&lt;/p&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="nv">&lt;p&gt;</span><span class="p">(</span><span class="nb">defun</span> <span class="nv">insert-binary-r</span> <span class="p">(</span><span class="nv">root</span> <span class="nv">data</span><span class="p">)</span>
</span><span class='line'>  <span class="p">(</span><span class="nb">cond</span> <span class="p">((</span><span class="nb">null</span> <span class="nv">root</span><span class="p">)</span> <span class="o">`</span><span class="p">(</span><span class="no">nil</span> <span class="o">,</span><span class="p">(</span><span class="nv">make-rb</span> <span class="ss">:data</span> <span class="nv">data</span><span class="p">)</span> <span class="no">nil</span><span class="p">))</span>
</span><span class='line'>        <span class="p">((</span><span class="nb">=</span> <span class="nv">data</span> <span class="p">(</span><span class="nv">node-data</span> <span class="nv">root</span><span class="p">))</span> <span class="nv">root</span><span class="p">)</span>
</span><span class='line'>        <span class="p">(</span><span class="no">T</span> <span class="p">(</span><span class="k">let*</span> <span class="p">((</span><span class="nv">dir</span> <span class="p">(</span><span class="nv">&amp;gt</span><span class="c1">; data (node-data root)))</span>
</span><span class='line'>                  <span class="p">(</span><span class="nv">x</span> <span class="p">(</span><span class="nb">cadr</span> <span class="nv">root</span><span class="p">))</span>
</span><span class='line'>                  <span class="p">(</span><span class="nv">a</span> <span class="p">(</span><span class="nv">kid</span> <span class="nv">root</span> <span class="p">(</span><span class="nb">not</span> <span class="nv">dir</span><span class="p">)))</span>
</span><span class='line'>                  <span class="p">(</span><span class="nv">b</span> <span class="p">(</span><span class="nv">binary-insert-r</span> <span class="p">(</span><span class="nv">kid</span> <span class="nv">root</span> <span class="nv">dir</span><span class="p">)</span> <span class="nv">data</span><span class="p">)))</span>
</span><span class='line'>             <span class="p">(</span><span class="nv">mtree-expand</span> <span class="nv">dir</span> <span class="p">(</span><span class="nv">a</span> <span class="nv">x</span> <span class="nv">b</span><span class="p">))))))</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<h3 id="macro-that-simplify-the-input-form">Macro that simplify the input form</h3>

<p>We also want to simplify that ugly <code>let</code> form, so we create this function and
macro:</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class='cl'><span class='line'><span class="p">(</span><span class="nb">defun</span> <span class="nv">gen-let</span> <span class="p">(</span><span class="nv">dir</span> <span class="nv">node</span> <span class="nv">form</span> <span class="nv">dirs</span><span class="p">)</span>
</span><span class='line'>  <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nb">atom</span> <span class="nv">form</span><span class="p">)</span>
</span><span class='line'>    <span class="nv">&lt;code&gt;</span><span class="p">((</span><span class="o">,</span><span class="nv">form</span> <span class="p">(</span><span class="nb">apply</span> <span class="nf">#&#39;</span><span class="nv">kid</span> <span class="o">,</span><span class="nv">node</span> <span class="o">,</span><span class="p">(</span><span class="nb">cons</span> <span class="ss">&#39;list</span> <span class="p">(</span><span class="nb">reverse</span> <span class="nv">dirs</span><span class="p">)))))</span>
</span><span class='line'>    <span class="p">(</span><span class="nb">cons</span> <span class="nv">&lt;/code&gt;</span><span class="p">(</span><span class="o">,</span><span class="p">(</span><span class="nb">cadr</span> <span class="nv">form</span><span class="p">)</span>
</span><span class='line'>            <span class="p">(</span><span class="nb">cadr</span> <span class="p">(</span><span class="nb">apply</span> <span class="err">#’</span><span class="nv">kid</span> <span class="o">,</span><span class="nv">node</span> <span class="o">,</span><span class="p">(</span><span class="nb">cons</span> <span class="err">‘</span><span class="nb">list</span> <span class="p">(</span><span class="nb">reverse</span> <span class="nv">dirs</span><span class="p">)))))</span>
</span><span class='line'>          <span class="p">(</span><span class="nb">append</span> <span class="p">(</span><span class="nv">gen-let</span> <span class="nv">dir</span> <span class="nv">node</span> <span class="p">(</span><span class="nb">car</span> <span class="nv">form</span><span class="p">)</span> <span class="p">(</span><span class="nb">cons</span> <span class="o">`</span><span class="p">(</span><span class="nb">not</span> <span class="o">,</span><span class="nv">dir</span><span class="p">)</span> <span class="nv">dirs</span><span class="p">))</span>
</span><span class='line'>                  <span class="p">(</span><span class="nv">gen-let</span> <span class="nv">dir</span> <span class="nv">node</span> <span class="p">(</span><span class="nb">caddr</span> <span class="nv">form</span><span class="p">)</span> <span class="p">(</span><span class="nb">cons</span> <span class="nv">dir</span> <span class="nv">dirs</span><span class="p">))))))</span><span class="nv">&lt;/p&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="nv">&lt;p&gt;</span><span class="p">(</span><span class="nb">defmacro</span> <span class="nv">mtree-let</span> <span class="p">(</span><span class="nv">dir</span> <span class="nv">node</span> <span class="nv">form</span> <span class="nv">let-var</span> <span class="nv">&amp;amp</span><span class="c1">;body body)</span>
</span><span class='line'>   <span class="o">`</span><span class="p">(</span><span class="k">let</span> <span class="o">,</span><span class="p">(</span><span class="nv">gen-let</span> <span class="nv">dir</span> <span class="nv">node</span> <span class="nv">form</span> <span class="no">nil</span><span class="p">)</span>
</span><span class='line'>       <span class="p">(</span><span class="k">let*</span> <span class="o">,</span><span class="nv">let-var</span>
</span><span class='line'>           <span class="o">,@</span><span class="nv">body</span><span class="p">)))</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>And then you can rewrite <code>rotate-s</code>:</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='cl'><span class='line'><span class="p">(</span><span class="nb">defun</span> <span class="nv">rotate-s</span> <span class="p">(</span><span class="nv">node</span> <span class="nv">dir</span><span class="p">)</span>
</span><span class='line'>  <span class="p">(</span><span class="nv">mtree-let</span> <span class="nv">dir</span> <span class="nv">node</span> <span class="p">((</span><span class="nv">a</span> <span class="nv">y</span> <span class="nv">b</span><span class="p">)</span> <span class="nv">x</span> <span class="nv">c</span><span class="p">)</span>
</span><span class='line'>    <span class="no">nil</span>
</span><span class='line'>    <span class="p">(</span><span class="nv">mtree-expand</span> <span class="p">(</span><span class="nv">a</span> <span class="nv">y</span> <span class="p">(</span><span class="nv">b</span> <span class="nv">x</span> <span class="nv">c</span><span class="p">)))))</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>See? We don’t need to write the comment to remind us the relative position of
variables. The code express itself! You can see what this code will expand
to by expanding the macro:</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='cl'><span class='line'><span class="nv">CL-USER&amp;gt</span><span class="c1">; (macroexpand-1 ‘(mtree-let dir node ((a y b) x c)</span>
</span><span class='line'>                          <span class="no">nil</span>
</span><span class='line'>                          <span class="p">(</span><span class="nv">mtree-expand</span> <span class="nv">dir</span> <span class="p">(</span><span class="nv">a</span> <span class="nv">y</span> <span class="p">(</span><span class="nv">b</span> <span class="nv">x</span> <span class="nv">c</span><span class="p">)))))</span>
</span><span class='line'><span class="p">(</span><span class="nv">LET</span> <span class="p">((</span><span class="nv">X</span> <span class="p">(</span><span class="nv">CADR</span> <span class="p">(</span><span class="nv">APPLY</span> <span class="err">#’</span><span class="nv">KID</span> <span class="nv">NODE</span> <span class="p">(</span><span class="nv">LIST</span><span class="p">))))</span>
</span><span class='line'>      <span class="p">(</span><span class="nv">Y</span> <span class="p">(</span><span class="nv">CADR</span> <span class="p">(</span><span class="nv">APPLY</span> <span class="err">#’</span><span class="nv">KID</span> <span class="nv">NODE</span> <span class="p">(</span><span class="nv">LIST</span> <span class="p">(</span><span class="nv">NOT</span> <span class="nv">DIR</span><span class="p">)))))</span>
</span><span class='line'>      <span class="p">(</span><span class="nv">A</span> <span class="p">(</span><span class="nv">APPLY</span> <span class="err">#’</span><span class="nv">KID</span> <span class="nv">NODE</span> <span class="p">(</span><span class="nv">LIST</span> <span class="p">(</span><span class="nv">NOT</span> <span class="nv">DIR</span><span class="p">)</span> <span class="p">(</span><span class="nv">NOT</span> <span class="nv">DIR</span><span class="p">))))</span>
</span><span class='line'>      <span class="p">(</span><span class="nv">B</span> <span class="p">(</span><span class="nv">APPLY</span> <span class="err">#’</span><span class="nv">KID</span> <span class="nv">NODE</span> <span class="p">(</span><span class="nv">LIST</span> <span class="p">(</span><span class="nv">NOT</span> <span class="nv">DIR</span><span class="p">)</span> <span class="nv">DIR</span><span class="p">)))</span>
</span><span class='line'>      <span class="p">(</span><span class="nv">C</span> <span class="p">(</span><span class="nv">APPLY</span> <span class="err">#’</span><span class="nv">KID</span> <span class="nv">NODE</span> <span class="p">(</span><span class="nv">LIST</span> <span class="nv">DIR</span><span class="p">))))</span>
</span><span class='line'>  <span class="p">(</span><span class="nv">LET*</span> <span class="p">()</span>
</span><span class='line'>    <span class="p">(</span><span class="nv">MTREE-EXPAND</span> <span class="nv">DIR</span> <span class="p">(</span><span class="nv">A</span> <span class="nv">Y</span> <span class="p">(</span><span class="nv">B</span> <span class="nv">X</span> <span class="nv">C</span><span class="p">)))))</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[persistent red black tree in lisp (1)]]></title>
    <link href="http://www.idryman.org/blog/2012/03/30/persistent-red-black-tree-in-lisp-1/"/>
    <updated>2012-03-30T13:57:00-07:00</updated>
    <id>http://www.idryman.org/blog/2012/03/30/persistent-red-black-tree-in-lisp-1</id>
    <content type="html"><![CDATA[<p>I’m a newbie to Lisp programing language. Lisp is one of the most oldest
programming language that is still being used today. People have a lot of
defences on programming languages, because there are too many choices to us
today. Every language has their strength and weakness. It is not easy to make
the choice.</p>

<p>In my opinion, the best way to decide what languages I must learn is to
see which kinds of people are loving it. 
For example, Ruby community does great supports for business plans; Python is
the best open sourced language for academia uses (scientific libraries, machine
learning, computer vision, statistics, visualizations…etc.) Many old school
hackers (including me) still love to use Perl; Java is widely used in big
companies; VBA is friendly for dealing excel data…etc. And <strong>Lisp</strong>, are
highly recommended by great hackers. </p>

<!-- more -->

<hr />

<p>If you are also interested in Lisp, I recommend <a href="http://www.gigamonkeys.com/book/">Practical Common
Lisp</a> written by <a href="http://www.gigamonkeys.com/">Peter Seibel</a>, and <a href="http://paulgraham.com/onlisp.html">On Lisp</a> written
by <a href="http://paulgraham.com/">Paul Graham</a>. Both of them are free, downloadable PDF files, and
there are also online version and epub format.</p>

<hr />

<h3 id="basic-thoughts">Basic thoughts</h3>

<p>Let’s begin with basic structures. At first, I design the structure similar to
what you will write in C code.</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='cl'><span class='line'><span class="p">(</span><span class="nb">defstruct</span> <span class="nv">rb</span>
</span><span class='line'>  <span class="nv">left</span>
</span><span class='line'>  <span class="nv">right</span>
</span><span class='line'>  <span class="nv">red</span>
</span><span class='line'>  <span class="nv">data</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>Here we can see the power of Lisp. It does not only create the structure, but
also create constructor and accessors for the structure. Now you can create the
<code>rb</code> and access it like so:</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
</pre></td><td class='code'><pre><code class='cl'><span class='line'><span class="p">(</span><span class="k">setq</span> <span class="nv">node</span>
</span><span class='line'>  <span class="p">(</span><span class="nv">make-rb</span> <span class="ss">:left</span> <span class="no">nil</span> <span class="ss">:right</span> <span class="no">nil</span> <span class="ss">:red</span> <span class="no">T</span> <span class="ss">:data</span> <span class="mi">3</span><span class="p">))</span><span class="nv">&lt;/p&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="nv">&lt;p&gt;==&amp;gt</span><span class="c1">; #S(RB :left nil :right nil :red T :data 3)&lt;/p&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="nv">&lt;p&gt;</span><span class="p">(</span><span class="nv">rb-left</span> <span class="nv">node</span><span class="p">)</span><span class="nv">&lt;/p&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="nv">&lt;p&gt;==&amp;gt</span><span class="c1">; nil&lt;/p&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="nv">&lt;p&gt;</span><span class="p">(</span><span class="nv">rb-data</span> <span class="nv">node</span><span class="p">)</span><span class="nv">&lt;/p&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="nv">&lt;p&gt;==&amp;gt</span><span class="c1">; 3&lt;/p&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="nv">&lt;p&gt;</span><span class="p">(</span><span class="nb">setf</span> <span class="p">(</span><span class="nv">rb-right</span> <span class="nv">node</span><span class="p">)</span> <span class="p">(</span><span class="nv">make-rb</span> <span class="ss">:data</span> <span class="mi">5</span><span class="p">))</span> <span class="c1">; Other field are default as nil&lt;/p&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="nv">&lt;p&gt;==&amp;gt</span><span class="c1">; #S(RB :left nil </span>
</span><span class='line'>          <span class="ss">:right</span> <span class="l-Other">#S</span><span class="p">(</span><span class="nv">RB</span> <span class="ss">:left</span> <span class="no">nil</span> <span class="ss">:right</span> <span class="no">nil</span> <span class="ss">:red</span> <span class="no">nil</span> <span class="ss">:data</span> <span class="mi">5</span><span class="p">)</span>
</span><span class='line'>          <span class="ss">:red</span> <span class="no">T</span> <span class="ss">:data</span> <span class="mi">3</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>This seems to be nice. But we can rewrite it in more lispy style:</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class='cl'><span class='line'><span class="p">(</span><span class="nb">defstruct</span> <span class="nv">rb</span>
</span><span class='line'>  <span class="p">(</span><span class="nv">red</span> <span class="no">T</span><span class="p">)</span> <span class="c1">; default value for red</span>
</span><span class='line'>  <span class="nv">data</span><span class="p">)</span><span class="nv">&lt;/p&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="nv">&lt;p&gt;</span><span class="c1">;; A node can be represented as</span>
</span><span class='line'><span class="c1">;; (nil #S(RB :red T :data 3) nil)</span>
</span><span class='line'><span class="c1">;; To generate this:</span>
</span><span class='line'><span class="p">(</span><span class="nb">list</span> <span class="no">nil</span> <span class="p">(</span><span class="nv">make-rb</span> <span class="ss">:data</span> <span class="mi">3</span><span class="p">)</span> <span class="no">nil</span><span class="p">)</span><span class="nv">&lt;/p&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="nv">&lt;p&gt;==&amp;gt</span><span class="c1">; (nil #S(RB :red T :data 3) nil)&lt;/p&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="nv">&lt;p&gt;</span><span class="c1">;; You can also use lisp syntax candy</span>
</span><span class='line'><span class="o">`</span><span class="p">(</span><span class="nb">list</span> <span class="no">nil</span> <span class="o">,</span><span class="p">(</span><span class="nv">make-rb</span> <span class="ss">:data</span> <span class="mi">3</span><span class="p">)</span> <span class="no">nil</span><span class="p">)</span><span class="nv">&lt;/p&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="nv">&lt;p&gt;==&amp;gt</span><span class="c1">; (nil #S(RB :red T :data 3) nil)</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>The s-expression with a preceding <code>`</code> means that it is a expression that
lisp don’t evaluate, except expression inside it with a preceding <code>,</code>. It is
convenient for us to generate new list object.</p>

<p>To access the elements in a list:</p>

<ol>
  <li><code>car</code> the first</li>
  <li><code>cadr</code> the second</li>
  <li><code>caddr</code> the third</li>
</ol>

<p>And now we can wirte a persistant basic binary insert function!</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
</pre></td><td class='code'><pre><code class='cl'><span class='line'><span class="p">(</span><span class="nb">defun</span> <span class="nv">binary-insert-r</span> <span class="p">(</span><span class="nv">root</span> <span class="nv">data</span><span class="p">)</span>
</span><span class='line'>  <span class="p">(</span><span class="nb">cond</span> <span class="p">((</span><span class="nb">null</span> <span class="nv">root</span><span class="p">)</span>                            <span class="c1">; cond works like “switch”</span>
</span><span class='line'>          <span class="o">`</span><span class="p">(</span><span class="no">nil</span> <span class="o">,</span><span class="p">(</span><span class="nv">make-rb</span> <span class="ss">:data</span> <span class="nv">data</span><span class="p">)</span> <span class="no">nil</span><span class="p">))</span>     <span class="c1">; make node when reach leaf</span>
</span><span class='line'>        <span class="p">((</span><span class="nb">=</span> <span class="nv">data</span> <span class="p">(</span><span class="nv">rb-data</span> <span class="p">(</span><span class="nb">cadr</span> <span class="nv">root</span><span class="p">)))</span> <span class="nv">root</span><span class="p">)</span>   <span class="c1">; return self if data is the same</span>
</span><span class='line'>        <span class="p">((</span><span class="nv">&amp;gt</span><span class="c1">; data (rb-data (cadr root)))</span>
</span><span class='line'>         <span class="p">(</span><span class="nb">list</span> <span class="p">(</span><span class="nb">car</span> <span class="nv">root</span><span class="p">)</span>                     <span class="nv">&lt;br</span> <span class="nv">/&gt;</span>
</span><span class='line'>               <span class="p">(</span><span class="nb">cadr</span> <span class="nv">root</span><span class="p">)</span>
</span><span class='line'>               <span class="p">(</span><span class="nv">binary-insert-r</span> <span class="p">(</span><span class="nb">caddr</span> <span class="nv">root</span><span class="p">)</span> <span class="nv">data</span><span class="p">)))</span> <span class="c1">; case insert to right</span>
</span><span class='line'>        <span class="p">(</span><span class="no">T</span>
</span><span class='line'>         <span class="p">(</span><span class="nb">list</span> <span class="p">(</span><span class="nv">binary-insert-r</span> <span class="p">(</span><span class="nb">car</span> <span class="nv">root</span><span class="p">)</span> <span class="nv">data</span><span class="p">)</span>
</span><span class='line'>               <span class="p">(</span><span class="nb">cadr</span> <span class="nv">root</span><span class="p">)</span>
</span><span class='line'>               <span class="p">(</span><span class="nb">caddr</span> <span class="nv">root</span><span class="p">)))))</span>                      <span class="c1">; case insert to left&lt;/p&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="nv">&lt;p&gt;</span><span class="p">(</span><span class="nb">defparameter</span> <span class="nv">&lt;em&gt;tree&lt;/em&gt;</span> <span class="no">nil</span><span class="p">)</span>                     <span class="c1">; global variable &lt;em&gt;tree&lt;/em&gt;</span>
</span><span class='line'><span class="p">(</span><span class="nb">defun</span> <span class="nv">binary-insert</span> <span class="p">(</span><span class="nv">data</span><span class="p">)</span>
</span><span class='line'>  <span class="p">(</span><span class="nb">setf</span> <span class="nv">&lt;em&gt;tree&lt;/em&gt;</span> <span class="p">(</span><span class="nv">binary-insert-r</span> <span class="nv">&lt;em&gt;tree&lt;/em&gt;</span> <span class="nv">data</span><span class="p">))</span> <span class="c1">; set &lt;em&gt;tree&lt;/em&gt; as the returned tree</span>
</span><span class='line'>  <span class="nv">&lt;em&gt;tree&lt;/em&gt;</span><span class="p">)</span>                                     <span class="c1">; return &lt;em&gt;tree&lt;/em&gt; value&lt;/p&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="nv">&lt;p&gt;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>Let’s exam the function:
<div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='cl'><span class='line'><span class="nv">BINARY-INSERT-R</span>
</span><span class='line'><span class="nv">CL-USER&amp;gt</span><span class="c1">; (binary-insert 6)</span>
</span><span class='line'><span class="p">(</span><span class="no">NIL</span> <span class="l-Other">#S</span><span class="p">(</span><span class="nv">RB</span> <span class="ss">:RED</span> <span class="no">T</span> <span class="ss">:DATA</span> <span class="mi">6</span><span class="p">)</span> <span class="no">NIL</span><span class="p">)</span>
</span><span class='line'><span class="nv">CL-USER&amp;gt</span><span class="c1">; (binary-insert 7)</span>
</span><span class='line'><span class="p">(</span><span class="no">NIL</span> <span class="l-Other">#S</span><span class="p">(</span><span class="nv">RB</span> <span class="ss">:RED</span> <span class="no">T</span> <span class="ss">:DATA</span> <span class="mi">6</span><span class="p">)</span> <span class="p">(</span><span class="no">NIL</span> <span class="l-Other">#S</span><span class="p">(</span><span class="nv">RB</span> <span class="ss">:RED</span> <span class="no">T</span> <span class="ss">:DATA</span> <span class="mi">7</span><span class="p">)</span> <span class="no">NIL</span><span class="p">))</span>
</span><span class='line'><span class="nv">CL-USER&amp;gt</span><span class="c1">; (binary-insert 5)</span>
</span><span class='line'><span class="p">((</span><span class="no">NIL</span> <span class="l-Other">#S</span><span class="p">(</span><span class="nv">RB</span> <span class="ss">:RED</span> <span class="no">T</span> <span class="ss">:DATA</span> <span class="mi">5</span><span class="p">)</span> <span class="no">NIL</span><span class="p">)</span> <span class="l-Other">#S</span><span class="p">(</span><span class="nv">RB</span> <span class="ss">:RED</span> <span class="no">T</span> <span class="ss">:DATA</span> <span class="mi">6</span><span class="p">)</span>
</span><span class='line'> <span class="p">(</span><span class="no">NIL</span> <span class="l-Other">#S</span><span class="p">(</span><span class="nv">RB</span> <span class="ss">:RED</span> <span class="no">T</span> <span class="ss">:DATA</span> <span class="mi">7</span><span class="p">)</span> <span class="no">NIL</span><span class="p">))</span>
</span><span class='line'><span class="nv">CL-USER&amp;gt</span><span class="c1">; (binary-insert 8)</span>
</span><span class='line'><span class="p">((</span><span class="no">NIL</span> <span class="l-Other">#S</span><span class="p">(</span><span class="nv">RB</span> <span class="ss">:RED</span> <span class="no">T</span> <span class="ss">:DATA</span> <span class="mi">5</span><span class="p">)</span> <span class="no">NIL</span><span class="p">)</span> <span class="l-Other">#S</span><span class="p">(</span><span class="nv">RB</span> <span class="ss">:RED</span> <span class="no">T</span> <span class="ss">:DATA</span> <span class="mi">6</span><span class="p">)</span>
</span><span class='line'>  <span class="p">(</span><span class="no">NIL</span> <span class="l-Other">#S</span><span class="p">(</span><span class="nv">RB</span> <span class="ss">:RED</span> <span class="no">T</span> <span class="ss">:DATA</span> <span class="mi">7</span><span class="p">)</span> <span class="p">(</span><span class="no">NIL</span> <span class="l-Other">#S</span><span class="p">(</span><span class="nv">RB</span> <span class="ss">:RED</span> <span class="no">T</span> <span class="ss">:DATA</span> <span class="mi">8</span><span class="p">)</span> <span class="no">NIL</span><span class="p">)))</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<h3 id="wait-hold-on">Wait! Hold on!</h3>

<p>The code is god damn ugly! We can fix it with some utilities:</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='cl'><span class='line'><span class="p">(</span><span class="nb">defun</span> <span class="nv">kid</span> <span class="p">(</span><span class="nv">root</span> <span class="nv">&amp;amp</span><span class="c1">;rest dirs)</span>
</span><span class='line'>  <span class="p">(</span><span class="nb">cond</span> <span class="p">((</span><span class="nb">consp</span> <span class="nv">dirs</span><span class="p">)</span>
</span><span class='line'>         <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nb">car</span> <span class="nv">dirs</span><span class="p">)</span>
</span><span class='line'>             <span class="p">(</span><span class="nb">apply</span> <span class="err">#’</span><span class="nv">kid</span> <span class="p">(</span><span class="nb">caddr</span> <span class="nv">root</span><span class="p">)</span> <span class="p">(</span><span class="nb">cdr</span> <span class="nv">dirs</span><span class="p">))</span>
</span><span class='line'>             <span class="p">(</span><span class="nb">apply</span> <span class="err">#’</span><span class="nv">kid</span> <span class="p">(</span><span class="nb">car</span> <span class="nv">root</span><span class="p">)</span> <span class="p">(</span><span class="nb">cdr</span> <span class="nv">dirs</span><span class="p">))))</span>
</span><span class='line'>        <span class="p">(</span><span class="no">T</span> <span class="nv">root</span><span class="p">)))</span><span class="nv">&lt;/p&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="nv">&lt;p&gt;</span><span class="p">(</span><span class="nb">defun</span> <span class="nv">node-data</span> <span class="p">(</span><span class="nv">root</span><span class="p">)</span>
</span><span class='line'>  <span class="p">(</span><span class="nv">rb-data</span> <span class="p">(</span><span class="nb">cadr</span> <span class="nv">root</span><span class="p">)))</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>The <code>kid</code> takes a node and a series of <code>T</code> and <code>nil</code>; When it saw a <code>T</code>, it
returns the right node, or it will return the left one. For example:</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='cl'><span class='line'><span class="nv">CL-USER&amp;gt</span><span class="c1">; (kid &lt;em&gt;tree&lt;/em&gt; nil)            ; left node</span>
</span><span class='line'><span class="p">(</span><span class="no">NIL</span> <span class="l-Other">#S</span><span class="p">(</span><span class="nv">RB</span> <span class="ss">:RED</span> <span class="no">T</span> <span class="ss">:DATA</span> <span class="mi">5</span><span class="p">)</span> <span class="no">NIL</span><span class="p">)</span>
</span><span class='line'><span class="nv">CL-USER&amp;gt</span><span class="c1">; (kid &lt;em&gt;tree&lt;/em&gt; T)              ; right node</span>
</span><span class='line'><span class="p">(</span><span class="no">NIL</span> <span class="l-Other">#S</span><span class="p">(</span><span class="nv">RB</span> <span class="ss">:RED</span> <span class="no">T</span> <span class="ss">:DATA</span> <span class="mi">7</span><span class="p">)</span> <span class="p">(</span><span class="no">NIL</span> <span class="l-Other">#S</span><span class="p">(</span><span class="nv">RB</span> <span class="ss">:RED</span> <span class="no">T</span> <span class="ss">:DATA</span> <span class="mi">8</span><span class="p">)</span> <span class="no">NIL</span><span class="p">))</span>
</span><span class='line'><span class="nv">CL-USER&amp;gt</span><span class="c1">; (kid &lt;em&gt;tree&lt;/em&gt; T T)            ; right right node</span>
</span><span class='line'><span class="p">(</span><span class="no">NIL</span> <span class="l-Other">#S</span><span class="p">(</span><span class="nv">RB</span> <span class="ss">:RED</span> <span class="no">T</span> <span class="ss">:DATA</span> <span class="mi">8</span><span class="p">)</span> <span class="no">NIL</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>Using <code>nil</code> and <code>T</code> as left and right dirctions, it is easier for us to rewrite
<code>binary-insert-r</code> because we can change left and right cases into variables.</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='cl'><span class='line'><span class="p">(</span><span class="nb">defun</span> <span class="nv">binary-insert-r</span> <span class="p">(</span><span class="nv">root</span> <span class="nv">data</span><span class="p">)</span>
</span><span class='line'>  <span class="p">(</span><span class="nb">cond</span> <span class="p">((</span><span class="nb">null</span> <span class="nv">root</span><span class="p">)</span> <span class="o">`</span><span class="p">(</span><span class="no">nil</span> <span class="o">,</span><span class="p">(</span><span class="nv">make-rb</span> <span class="ss">:data</span> <span class="nv">data</span><span class="p">)</span> <span class="no">nil</span><span class="p">))</span>
</span><span class='line'>        <span class="p">((</span><span class="nb">=</span> <span class="nv">data</span> <span class="p">(</span><span class="nv">node-data</span> <span class="nv">root</span><span class="p">))</span> <span class="nv">root</span><span class="p">)</span>
</span><span class='line'>        <span class="p">(</span><span class="no">T</span> <span class="p">(</span><span class="k">let*</span> <span class="p">((</span><span class="nv">dir</span> <span class="p">(</span><span class="nv">&amp;gt</span><span class="c1">; data (node-data root)))</span>
</span><span class='line'>                  <span class="p">(</span><span class="nv">a</span> <span class="p">(</span><span class="nv">kid</span> <span class="nv">root</span> <span class="p">(</span><span class="nb">not</span> <span class="nv">dir</span><span class="p">)))</span>
</span><span class='line'>                  <span class="p">(</span><span class="nv">b</span> <span class="p">(</span><span class="nv">binary-insert-r</span> <span class="p">(</span><span class="nv">kid</span> <span class="nv">root</span> <span class="nv">dir</span><span class="p">)</span> <span class="nv">data</span><span class="p">)))</span>
</span><span class='line'>             <span class="p">(</span><span class="k">if</span> <span class="nv">dir</span>
</span><span class='line'>                 <span class="p">(</span><span class="nb">list</span> <span class="nv">a</span> <span class="p">(</span><span class="nb">cadr</span> <span class="nv">root</span><span class="p">)</span> <span class="nv">b</span><span class="p">)</span>
</span><span class='line'>                 <span class="p">(</span><span class="nb">list</span> <span class="nv">b</span> <span class="p">(</span><span class="nb">cadr</span> <span class="nv">root</span><span class="p">)</span> <span class="nv">a</span><span class="p">))))))</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

]]></content>
  </entry>
  
</feed>
